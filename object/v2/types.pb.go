// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: object/v2/types.proto

package v2

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	v2 "github.com/nspcc-dev/neofs-api-go/refs/v2"
	v21 "github.com/nspcc-dev/neofs-api-go/service/v2"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Type of the object payload content
type ObjectType int32

const (
	// Just a normal object
	ObjectType_REGULAR ObjectType = 0
	// Used internally to identify deleted objects
	ObjectType_TOMBSTONE ObjectType = 1
	// Identifies that the object holds StorageGroup information
	ObjectType_STORAGE_GROUP ObjectType = 2
)

var ObjectType_name = map[int32]string{
	0: "REGULAR",
	1: "TOMBSTONE",
	2: "STORAGE_GROUP",
}

var ObjectType_value = map[string]int32{
	"REGULAR":       0,
	"TOMBSTONE":     1,
	"STORAGE_GROUP": 2,
}

func (x ObjectType) String() string {
	return proto.EnumName(ObjectType_name, int32(x))
}

func (ObjectType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_666bf7c1dc0e676f, []int{0}
}

type Header struct {
	// Object's container
	ContainerId *v2.ContainerID `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// Object's owner
	OwnerId *v2.OwnerID `protobuf:"bytes,2,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Epoch when the object was created
	CreationEpoch uint64 `protobuf:"varint,3,opt,name=creation_epoch,json=creationEpoch,proto3" json:"creation_epoch,omitempty"`
	// Object format version.
	// Effectively the version of API library used to create particular object
	Version *v21.Version `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	// Size of payload in bytes.
	// 0xFFFFFFFFFFFFFFFF means `payload_length` is unknown
	PayloadLength uint64 `protobuf:"varint,5,opt,name=payload_length,json=payloadLength,proto3" json:"payload_length,omitempty"`
	// Hash of payload bytes
	PayloadHash []byte     `protobuf:"bytes,6,opt,name=payload_hash,json=payloadHash,proto3" json:"payload_hash,omitempty"`
	ObjectType  ObjectType `protobuf:"varint,7,opt,name=object_type,json=objectType,proto3,enum=object.v2.ObjectType" json:"object_type,omitempty"`
	// Homomorphic hash of the object payload.
	HomomorphicHash []byte `protobuf:"bytes,8,opt,name=homomorphic_hash,json=homomorphicHash,proto3" json:"homomorphic_hash,omitempty"`
	// Session token, if it was used during Object creation.
	// Need it to verify integrity and authenticity out of Request scope.
	SessionToken *v21.SessionToken   `protobuf:"bytes,9,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	Attributes   []*Header_Attribute `protobuf:"bytes,10,rep,name=attributes,proto3" json:"attributes,omitempty"`
	// Position of the object in the split hierarchy.
	Split                *Header_Split `protobuf:"bytes,11,opt,name=split,proto3" json:"split,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_666bf7c1dc0e676f, []int{0}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetContainerId() *v2.ContainerID {
	if m != nil {
		return m.ContainerId
	}
	return nil
}

func (m *Header) GetOwnerId() *v2.OwnerID {
	if m != nil {
		return m.OwnerId
	}
	return nil
}

func (m *Header) GetCreationEpoch() uint64 {
	if m != nil {
		return m.CreationEpoch
	}
	return 0
}

func (m *Header) GetVersion() *v21.Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *Header) GetPayloadLength() uint64 {
	if m != nil {
		return m.PayloadLength
	}
	return 0
}

func (m *Header) GetPayloadHash() []byte {
	if m != nil {
		return m.PayloadHash
	}
	return nil
}

func (m *Header) GetObjectType() ObjectType {
	if m != nil {
		return m.ObjectType
	}
	return ObjectType_REGULAR
}

func (m *Header) GetHomomorphicHash() []byte {
	if m != nil {
		return m.HomomorphicHash
	}
	return nil
}

func (m *Header) GetSessionToken() *v21.SessionToken {
	if m != nil {
		return m.SessionToken
	}
	return nil
}

func (m *Header) GetAttributes() []*Header_Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Header) GetSplit() *Header_Split {
	if m != nil {
		return m.Split
	}
	return nil
}

// Attribute groups the user-defined Key-Value pairs attached to the object
type Header_Attribute struct {
	// string key to the object attribute
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// string value of the object attribute
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Header_Attribute) Reset()         { *m = Header_Attribute{} }
func (m *Header_Attribute) String() string { return proto.CompactTextString(m) }
func (*Header_Attribute) ProtoMessage()    {}
func (*Header_Attribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_666bf7c1dc0e676f, []int{0, 0}
}
func (m *Header_Attribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header_Attribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header_Attribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header_Attribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header_Attribute.Merge(m, src)
}
func (m *Header_Attribute) XXX_Size() int {
	return m.Size()
}
func (m *Header_Attribute) XXX_DiscardUnknown() {
	xxx_messageInfo_Header_Attribute.DiscardUnknown(m)
}

var xxx_messageInfo_Header_Attribute proto.InternalMessageInfo

func (m *Header_Attribute) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Header_Attribute) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Information about spawning the objects through a payload splitting.
type Header_Split struct {
	// Identifier of the origin object.v2.
	// Parent and children objects must be within the same container.v2.
	// Parent object_id is known only to the minor child.
	Parent *v2.ObjectID `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// Previous carries identifier of the left split neighbor.
	Previous *v2.ObjectID `protobuf:"bytes,2,opt,name=previous,proto3" json:"previous,omitempty"`
	// `signature` field of the parent object.v2. Used to reconstruct parent.
	ParentSignature *v21.Signature `protobuf:"bytes,3,opt,name=parent_signature,json=parentSignature,proto3" json:"parent_signature,omitempty"`
	// `header` field of the parent object.v2. Used to reconstruct parent.
	ParentHeader *Header `protobuf:"bytes,4,opt,name=parent_header,json=parentHeader,proto3" json:"parent_header,omitempty"`
	// Children carries list of identifiers of the objects generated by splitting the current.
	Children             []*v2.ObjectID `protobuf:"bytes,5,rep,name=children,proto3" json:"children,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Header_Split) Reset()         { *m = Header_Split{} }
func (m *Header_Split) String() string { return proto.CompactTextString(m) }
func (*Header_Split) ProtoMessage()    {}
func (*Header_Split) Descriptor() ([]byte, []int) {
	return fileDescriptor_666bf7c1dc0e676f, []int{0, 1}
}
func (m *Header_Split) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header_Split) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header_Split.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header_Split) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header_Split.Merge(m, src)
}
func (m *Header_Split) XXX_Size() int {
	return m.Size()
}
func (m *Header_Split) XXX_DiscardUnknown() {
	xxx_messageInfo_Header_Split.DiscardUnknown(m)
}

var xxx_messageInfo_Header_Split proto.InternalMessageInfo

func (m *Header_Split) GetParent() *v2.ObjectID {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *Header_Split) GetPrevious() *v2.ObjectID {
	if m != nil {
		return m.Previous
	}
	return nil
}

func (m *Header_Split) GetParentSignature() *v21.Signature {
	if m != nil {
		return m.ParentSignature
	}
	return nil
}

func (m *Header_Split) GetParentHeader() *Header {
	if m != nil {
		return m.ParentHeader
	}
	return nil
}

func (m *Header_Split) GetChildren() []*v2.ObjectID {
	if m != nil {
		return m.Children
	}
	return nil
}

// Object structure.
type Object struct {
	// Object's unique identifier.
	// Object is content-addressed. It means id will change if header or payload
	// changes. It's calculated as a hash of header field, which contains hash of
	// object's payload
	ObjectId *v2.ObjectID `protobuf:"bytes,1,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	// Signed object_id
	Signature *v21.Signature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// Object metadata headers
	Header *Header `protobuf:"bytes,3,opt,name=header,proto3" json:"header,omitempty"`
	// Payload bytes.
	Payload              []byte   `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Object) Reset()         { *m = Object{} }
func (m *Object) String() string { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()    {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_666bf7c1dc0e676f, []int{1}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Object.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetObjectId() *v2.ObjectID {
	if m != nil {
		return m.ObjectId
	}
	return nil
}

func (m *Object) GetSignature() *v21.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Object) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Object) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func init() {
	proto.RegisterEnum("object.v2.ObjectType", ObjectType_name, ObjectType_value)
	proto.RegisterType((*Header)(nil), "object.v2.Header")
	proto.RegisterType((*Header_Attribute)(nil), "object.v2.Header.Attribute")
	proto.RegisterType((*Header_Split)(nil), "object.v2.Header.Split")
	proto.RegisterType((*Object)(nil), "object.v2.Object")
}

func init() { proto.RegisterFile("object/v2/types.proto", fileDescriptor_666bf7c1dc0e676f) }

var fileDescriptor_666bf7c1dc0e676f = []byte{
	// 704 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0x5f, 0x4e, 0xdb, 0x4a,
	0x14, 0xc6, 0x71, 0x42, 0xfe, 0x1d, 0x27, 0x60, 0x06, 0x22, 0xac, 0x5c, 0x29, 0xca, 0x45, 0xba,
	0x52, 0xb8, 0x28, 0x8e, 0x14, 0x24, 0xee, 0x03, 0xba, 0x52, 0x43, 0x49, 0x21, 0x12, 0x25, 0x68,
	0x12, 0xfa, 0xd0, 0x97, 0xc8, 0xb1, 0x87, 0xd8, 0x25, 0xf1, 0x58, 0xf6, 0xc4, 0x28, 0x5b, 0xe8,
	0x0a, 0xba, 0x86, 0x3e, 0x76, 0x15, 0x7d, 0xec, 0x0a, 0xaa, 0x8a, 0x6e, 0xa4, 0xf2, 0xcc, 0xd8,
	0x49, 0x0b, 0xed, 0xdb, 0xcc, 0x77, 0x7e, 0xe7, 0xcc, 0x7c, 0xc7, 0x67, 0x0c, 0x55, 0x3a, 0x79,
	0x47, 0x2c, 0xd6, 0x8e, 0x3a, 0x6d, 0xb6, 0xf4, 0x49, 0x68, 0xf8, 0x01, 0x65, 0x14, 0x95, 0x84,
	0x6c, 0x44, 0x9d, 0xda, 0x6e, 0x40, 0xee, 0xc2, 0x5f, 0xe2, 0xb5, 0x6a, 0x48, 0x82, 0xc8, 0xb5,
	0x48, 0xac, 0xcf, 0x09, 0x33, 0xa5, 0xbc, 0xbf, 0x26, 0x47, 0x24, 0x70, 0xef, 0x96, 0x22, 0x70,
	0xf0, 0x35, 0x0f, 0xf9, 0x4b, 0x62, 0xda, 0x24, 0x40, 0xff, 0x41, 0xd9, 0xa2, 0x1e, 0x33, 0x5d,
	0x8f, 0x04, 0x63, 0xd7, 0xd6, 0x95, 0x86, 0xd2, 0x54, 0x3b, 0x7b, 0x46, 0x7c, 0x8c, 0x11, 0x75,
	0x8c, 0x97, 0x49, 0xb0, 0x7f, 0x8e, 0xd5, 0x94, 0xec, 0xdb, 0xe8, 0x08, 0x8a, 0xf4, 0x41, 0x26,
	0x65, 0x78, 0x92, 0x96, 0x26, 0x0d, 0x1e, 0x44, 0x42, 0x81, 0x13, 0x7d, 0x1b, 0xfd, 0x03, 0x5b,
	0x56, 0x40, 0x4c, 0xe6, 0x52, 0x6f, 0x4c, 0x7c, 0x6a, 0x39, 0x7a, 0xb6, 0xa1, 0x34, 0x37, 0x71,
	0x25, 0x51, 0x7b, 0xb1, 0x88, 0x5a, 0x50, 0x88, 0x48, 0x10, 0xba, 0xd4, 0xd3, 0x37, 0x79, 0xc9,
	0x5d, 0x43, 0x5a, 0x88, 0xab, 0xbe, 0x11, 0x21, 0x9c, 0x30, 0x71, 0x55, 0xdf, 0x5c, 0xce, 0xa8,
	0x69, 0x8f, 0x67, 0xc4, 0x9b, 0x32, 0x47, 0xcf, 0x89, 0xaa, 0x52, 0xbd, 0xe2, 0x22, 0xfa, 0x1b,
	0xca, 0x09, 0xe6, 0x98, 0xa1, 0xa3, 0xe7, 0x1b, 0x4a, 0xb3, 0x8c, 0x55, 0xa9, 0x5d, 0x9a, 0xa1,
	0x83, 0x4e, 0x40, 0x15, 0x2d, 0x1e, 0xc7, 0x6d, 0xd5, 0x0b, 0x0d, 0xa5, 0xb9, 0xd5, 0xa9, 0x1a,
	0x69, 0xdb, 0x8d, 0x01, 0x5f, 0x8d, 0x96, 0x3e, 0xc1, 0x40, 0xd3, 0x35, 0x3a, 0x04, 0xcd, 0xa1,
	0x73, 0x3a, 0xa7, 0x81, 0xef, 0xb8, 0x96, 0x28, 0x5f, 0xe4, 0xe5, 0xb7, 0xd7, 0x74, 0x7e, 0xc4,
	0xff, 0x50, 0x09, 0x49, 0x18, 0xdf, 0x7b, 0xcc, 0xe8, 0x3d, 0xf1, 0xf4, 0x12, 0x77, 0xa8, 0xaf,
	0x3b, 0x1c, 0x0a, 0x60, 0x14, 0xc7, 0x71, 0x39, 0x5c, 0xdb, 0xa1, 0x53, 0x00, 0x93, 0xb1, 0xc0,
	0x9d, 0x2c, 0x18, 0x09, 0x75, 0x68, 0x64, 0x9b, 0x6a, 0xe7, 0xaf, 0xb5, 0x0b, 0x8a, 0xcf, 0x69,
	0x74, 0x13, 0x06, 0xaf, 0xe1, 0xa8, 0x05, 0xb9, 0xd0, 0x9f, 0xb9, 0x4c, 0x57, 0xf9, 0x99, 0xfb,
	0x4f, 0xf3, 0x86, 0x71, 0x18, 0x0b, 0xaa, 0x76, 0x0c, 0xa5, 0xb4, 0x0e, 0xd2, 0x20, 0x7b, 0x4f,
	0x96, 0x7c, 0x2e, 0x4a, 0x38, 0x5e, 0xa2, 0x3d, 0xc8, 0x45, 0xe6, 0x6c, 0x41, 0xf8, 0x67, 0x2f,
	0x61, 0xb1, 0xa9, 0xbd, 0xcf, 0x40, 0x8e, 0x57, 0x41, 0x87, 0x90, 0xf7, 0xcd, 0x80, 0x78, 0x4c,
	0x0e, 0xd3, 0xce, 0x6a, 0x2e, 0xf8, 0xb1, 0xfd, 0x73, 0x2c, 0x01, 0xd4, 0x82, 0xa2, 0x1f, 0x90,
	0xc8, 0xa5, 0x8b, 0x50, 0x0e, 0xd1, 0x33, 0x70, 0x8a, 0xa0, 0x17, 0xa0, 0x89, 0xc4, 0x71, 0xe8,
	0x4e, 0x3d, 0x93, 0x2d, 0x02, 0xc2, 0x07, 0x49, 0xed, 0x54, 0x7f, 0x6a, 0x63, 0x12, 0xc4, 0xdb,
	0x02, 0x4f, 0x05, 0x74, 0x02, 0x15, 0x59, 0xc1, 0xe1, 0xc6, 0xe5, 0x9c, 0xed, 0x3c, 0xe9, 0x08,
	0x2e, 0x0b, 0x4e, 0x3e, 0x93, 0x16, 0x14, 0x2d, 0xc7, 0x9d, 0xd9, 0x01, 0xf1, 0xf4, 0x1c, 0x6f,
	0xfe, 0x73, 0x17, 0x4d, 0x90, 0x83, 0x4f, 0x0a, 0xe4, 0x85, 0x8c, 0x0c, 0x90, 0xaf, 0x77, 0xf5,
	0xba, 0x9e, 0x4b, 0x15, 0x4c, 0xdf, 0x46, 0xc7, 0x50, 0x5a, 0x99, 0xcb, 0xfc, 0xc9, 0xdc, 0x8a,
	0x8b, 0x5b, 0x2e, 0xfd, 0x64, 0x7f, 0xe7, 0x47, 0x02, 0x48, 0x87, 0x82, 0x9c, 0x7c, 0xee, 0xbd,
	0x8c, 0x93, 0xed, 0xbf, 0xa7, 0x00, 0xab, 0x31, 0x47, 0x2a, 0x14, 0x70, 0xef, 0xe2, 0xf6, 0xaa,
	0x8b, 0xb5, 0x0d, 0x54, 0x81, 0xd2, 0x68, 0xf0, 0xfa, 0x6c, 0x38, 0x1a, 0x5c, 0xf7, 0x34, 0x05,
	0xed, 0x40, 0x65, 0x38, 0x1a, 0xe0, 0xee, 0x45, 0x6f, 0x7c, 0x81, 0x07, 0xb7, 0x37, 0x5a, 0xe6,
	0xec, 0xe6, 0xf3, 0x63, 0x5d, 0xf9, 0xf2, 0x58, 0x57, 0xbe, 0x3d, 0xd6, 0x95, 0x0f, 0xdf, 0xeb,
	0x1b, 0x6f, 0x8f, 0xa6, 0x2e, 0x73, 0x16, 0x13, 0xc3, 0xa2, 0xf3, 0xb6, 0x17, 0xfa, 0x96, 0xd5,
	0xb2, 0x49, 0xd4, 0xf6, 0x08, 0xbd, 0x0b, 0x5b, 0xa6, 0xef, 0xb6, 0xa6, 0xb4, 0x9d, 0xfe, 0xed,
	0x3e, 0x66, 0xb4, 0x6b, 0x42, 0x5f, 0x0d, 0x8d, 0xee, 0x4d, 0x5f, 0x36, 0x65, 0x92, 0xe7, 0xff,
	0xaa, 0xe3, 0x1f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xeb, 0x34, 0x17, 0x81, 0x14, 0x05, 0x00, 0x00,
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Split != nil {
		{
			size, err := m.Split.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.SessionToken != nil {
		{
			size, err := m.SessionToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.HomomorphicHash) > 0 {
		i -= len(m.HomomorphicHash)
		copy(dAtA[i:], m.HomomorphicHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HomomorphicHash)))
		i--
		dAtA[i] = 0x42
	}
	if m.ObjectType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PayloadHash) > 0 {
		i -= len(m.PayloadHash)
		copy(dAtA[i:], m.PayloadHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PayloadHash)))
		i--
		dAtA[i] = 0x32
	}
	if m.PayloadLength != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PayloadLength))
		i--
		dAtA[i] = 0x28
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CreationEpoch != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreationEpoch))
		i--
		dAtA[i] = 0x18
	}
	if m.OwnerId != nil {
		{
			size, err := m.OwnerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ContainerId != nil {
		{
			size, err := m.ContainerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header_Attribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header_Attribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Attribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header_Split) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header_Split) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Split) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ParentHeader != nil {
		{
			size, err := m.ParentHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ParentSignature != nil {
		{
			size, err := m.ParentSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Previous != nil {
		{
			size, err := m.Previous.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Parent != nil {
		{
			size, err := m.Parent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x22
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ObjectId != nil {
		{
			size, err := m.ObjectId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerId != nil {
		l = m.ContainerId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OwnerId != nil {
		l = m.OwnerId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationEpoch != 0 {
		n += 1 + sovTypes(uint64(m.CreationEpoch))
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PayloadLength != 0 {
		n += 1 + sovTypes(uint64(m.PayloadLength))
	}
	l = len(m.PayloadHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ObjectType != 0 {
		n += 1 + sovTypes(uint64(m.ObjectType))
	}
	l = len(m.HomomorphicHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SessionToken != nil {
		l = m.SessionToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Split != nil {
		l = m.Split.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header_Attribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header_Split) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parent != nil {
		l = m.Parent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Previous != nil {
		l = m.Previous.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ParentSignature != nil {
		l = m.ParentSignature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ParentHeader != nil {
		l = m.ParentHeader.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectId != nil {
		l = m.ObjectId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerId == nil {
				m.ContainerId = &v2.ContainerID{}
			}
			if err := m.ContainerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerId == nil {
				m.OwnerId = &v2.OwnerID{}
			}
			if err := m.OwnerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationEpoch", wireType)
			}
			m.CreationEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &v21.Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadLength", wireType)
			}
			m.PayloadLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadHash = append(m.PayloadHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PayloadHash == nil {
				m.PayloadHash = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectType", wireType)
			}
			m.ObjectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectType |= ObjectType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomomorphicHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomomorphicHash = append(m.HomomorphicHash[:0], dAtA[iNdEx:postIndex]...)
			if m.HomomorphicHash == nil {
				m.HomomorphicHash = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionToken == nil {
				m.SessionToken = &v21.SessionToken{}
			}
			if err := m.SessionToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &Header_Attribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Split == nil {
				m.Split = &Header_Split{}
			}
			if err := m.Split.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header_Attribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header_Split) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Split: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Split: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &v2.ObjectID{}
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Previous", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Previous == nil {
				m.Previous = &v2.ObjectID{}
			}
			if err := m.Previous.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentSignature == nil {
				m.ParentSignature = &v21.Signature{}
			}
			if err := m.ParentSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentHeader == nil {
				m.ParentHeader = &Header{}
			}
			if err := m.ParentHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &v2.ObjectID{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectId == nil {
				m.ObjectId = &v2.ObjectID{}
			}
			if err := m.ObjectId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &v21.Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
