// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v2/service/meta.proto

package service

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	acl "github.com/nspcc-dev/neofs-api-go/v2/acl"
	refs "github.com/nspcc-dev/neofs-api-go/v2/refs"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Verb is an enumeration of session request types
type SessionToken_Body_Verb int32

const (
	// Refers to object.Put RPC call
	SessionToken_Body_OBJECT_PUT SessionToken_Body_Verb = 0
	// Refers to object.Get RPC call
	SessionToken_Body_OBJECT_GET SessionToken_Body_Verb = 1
	// Refers to object.Head RPC call
	SessionToken_Body_OBJECT_HEAD SessionToken_Body_Verb = 2
	// Refers to object.Search RPC call
	SessionToken_Body_OBJECT_SEARCH SessionToken_Body_Verb = 3
	// Refers to object.Delete RPC call
	SessionToken_Body_OBJECT_DELETE SessionToken_Body_Verb = 4
	// Refers to object.GetRange RPC call
	SessionToken_Body_OBJECT_RANGE SessionToken_Body_Verb = 5
	// Refers to object.GetRangeHash RPC call
	SessionToken_Body_OBJECT_RANGEHASH SessionToken_Body_Verb = 6
)

var SessionToken_Body_Verb_name = map[int32]string{
	0: "OBJECT_PUT",
	1: "OBJECT_GET",
	2: "OBJECT_HEAD",
	3: "OBJECT_SEARCH",
	4: "OBJECT_DELETE",
	5: "OBJECT_RANGE",
	6: "OBJECT_RANGEHASH",
}

var SessionToken_Body_Verb_value = map[string]int32{
	"OBJECT_PUT":       0,
	"OBJECT_GET":       1,
	"OBJECT_HEAD":      2,
	"OBJECT_SEARCH":    3,
	"OBJECT_DELETE":    4,
	"OBJECT_RANGE":     5,
	"OBJECT_RANGEHASH": 6,
}

func (x SessionToken_Body_Verb) String() string {
	return proto.EnumName(SessionToken_Body_Verb_name, int32(x))
}

func (SessionToken_Body_Verb) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_932e020d69aee3f0, []int{3, 0, 0}
}

type XHeader struct {
	// Key of the X-Header.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Value of the X-Header.
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XHeader) Reset()         { *m = XHeader{} }
func (m *XHeader) String() string { return proto.CompactTextString(m) }
func (*XHeader) ProtoMessage()    {}
func (*XHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_932e020d69aee3f0, []int{0}
}
func (m *XHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XHeader.Merge(m, src)
}
func (m *XHeader) XXX_Size() int {
	return m.Size()
}
func (m *XHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_XHeader.DiscardUnknown(m)
}

var xxx_messageInfo_XHeader proto.InternalMessageInfo

func (m *XHeader) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *XHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Represents API version used by node.
type Version struct {
	// Major API version.
	Major uint32 `protobuf:"varint,1,opt,name=major,proto3" json:"major,omitempty"`
	// Minor API version.
	Minor                uint32   `protobuf:"varint,2,opt,name=minor,proto3" json:"minor,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_932e020d69aee3f0, []int{1}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Version.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return m.Size()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetMajor() uint32 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *Version) GetMinor() uint32 {
	if m != nil {
		return m.Minor
	}
	return 0
}

// Lifetime parameters of the token. Filed names taken from rfc7519.
type TokenLifetime struct {
	// Expiration Epoch
	Exp uint64 `protobuf:"varint,1,opt,name=exp,proto3" json:"exp,omitempty"`
	// Not valid before Epoch
	Nbf uint64 `protobuf:"varint,2,opt,name=nbf,proto3" json:"nbf,omitempty"`
	// Issued at Epoch
	Iat                  uint64   `protobuf:"varint,3,opt,name=iat,proto3" json:"iat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokenLifetime) Reset()         { *m = TokenLifetime{} }
func (m *TokenLifetime) String() string { return proto.CompactTextString(m) }
func (*TokenLifetime) ProtoMessage()    {}
func (*TokenLifetime) Descriptor() ([]byte, []int) {
	return fileDescriptor_932e020d69aee3f0, []int{2}
}
func (m *TokenLifetime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenLifetime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenLifetime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenLifetime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenLifetime.Merge(m, src)
}
func (m *TokenLifetime) XXX_Size() int {
	return m.Size()
}
func (m *TokenLifetime) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenLifetime.DiscardUnknown(m)
}

var xxx_messageInfo_TokenLifetime proto.InternalMessageInfo

func (m *TokenLifetime) GetExp() uint64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *TokenLifetime) GetNbf() uint64 {
	if m != nil {
		return m.Nbf
	}
	return 0
}

func (m *TokenLifetime) GetIat() uint64 {
	if m != nil {
		return m.Iat
	}
	return 0
}

// NeoFS session token.
type SessionToken struct {
	// Session Token body
	Token *SessionToken_Body `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// Signature is a signature of session token information
	Signature            *Signature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SessionToken) Reset()         { *m = SessionToken{} }
func (m *SessionToken) String() string { return proto.CompactTextString(m) }
func (*SessionToken) ProtoMessage()    {}
func (*SessionToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_932e020d69aee3f0, []int{3}
}
func (m *SessionToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionToken.Merge(m, src)
}
func (m *SessionToken) XXX_Size() int {
	return m.Size()
}
func (m *SessionToken) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionToken.DiscardUnknown(m)
}

var xxx_messageInfo_SessionToken proto.InternalMessageInfo

func (m *SessionToken) GetToken() *SessionToken_Body {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *SessionToken) GetSignature() *Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

type SessionToken_Body struct {
	// ID is a token identifier. valid UUIDv4 represented in bytes
	Id []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// OwnerID carries identifier of the session initiator.
	OwnerId *refs.OwnerID `protobuf:"bytes,2,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Verb is a type of request for which the token is issued
	Verb SessionToken_Body_Verb `protobuf:"varint,3,opt,name=verb,proto3,enum=neo.fs.v2.service.SessionToken_Body_Verb" json:"verb,omitempty"`
	// Lifetime is a lifetime of the session
	Lifetime *TokenLifetime `protobuf:"bytes,4,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
	// SessionKey is a public key of session key
	SessionKey []byte `protobuf:"bytes,5,opt,name=session_key,json=sessionKey,proto3" json:"session_key,omitempty"`
	// Carries context of the session.
	//
	// Types that are valid to be assigned to Context:
	//	*SessionToken_Body_ObjectAddress
	Context              isSessionToken_Body_Context `protobuf_oneof:"context"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *SessionToken_Body) Reset()         { *m = SessionToken_Body{} }
func (m *SessionToken_Body) String() string { return proto.CompactTextString(m) }
func (*SessionToken_Body) ProtoMessage()    {}
func (*SessionToken_Body) Descriptor() ([]byte, []int) {
	return fileDescriptor_932e020d69aee3f0, []int{3, 0}
}
func (m *SessionToken_Body) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionToken_Body) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionToken_Body.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionToken_Body) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionToken_Body.Merge(m, src)
}
func (m *SessionToken_Body) XXX_Size() int {
	return m.Size()
}
func (m *SessionToken_Body) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionToken_Body.DiscardUnknown(m)
}

var xxx_messageInfo_SessionToken_Body proto.InternalMessageInfo

type isSessionToken_Body_Context interface {
	isSessionToken_Body_Context()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionToken_Body_ObjectAddress struct {
	ObjectAddress *refs.Address `protobuf:"bytes,6,opt,name=object_address,json=objectAddress,proto3,oneof" json:"object_address,omitempty"`
}

func (*SessionToken_Body_ObjectAddress) isSessionToken_Body_Context() {}

func (m *SessionToken_Body) GetContext() isSessionToken_Body_Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *SessionToken_Body) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SessionToken_Body) GetOwnerId() *refs.OwnerID {
	if m != nil {
		return m.OwnerId
	}
	return nil
}

func (m *SessionToken_Body) GetVerb() SessionToken_Body_Verb {
	if m != nil {
		return m.Verb
	}
	return SessionToken_Body_OBJECT_PUT
}

func (m *SessionToken_Body) GetLifetime() *TokenLifetime {
	if m != nil {
		return m.Lifetime
	}
	return nil
}

func (m *SessionToken_Body) GetSessionKey() []byte {
	if m != nil {
		return m.SessionKey
	}
	return nil
}

func (m *SessionToken_Body) GetObjectAddress() *refs.Address {
	if x, ok := m.GetContext().(*SessionToken_Body_ObjectAddress); ok {
		return x.ObjectAddress
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionToken_Body) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionToken_Body_ObjectAddress)(nil),
	}
}

// BearerToken has information about request ACL rules with limited lifetime
type BearerToken struct {
	// Bearer Token body
	Token *BearerToken_Body `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// Signature of BearerToken body
	Signature            *Signature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BearerToken) Reset()         { *m = BearerToken{} }
func (m *BearerToken) String() string { return proto.CompactTextString(m) }
func (*BearerToken) ProtoMessage()    {}
func (*BearerToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_932e020d69aee3f0, []int{4}
}
func (m *BearerToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerToken.Merge(m, src)
}
func (m *BearerToken) XXX_Size() int {
	return m.Size()
}
func (m *BearerToken) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerToken.DiscardUnknown(m)
}

var xxx_messageInfo_BearerToken proto.InternalMessageInfo

func (m *BearerToken) GetToken() *BearerToken_Body {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *BearerToken) GetSignature() *Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

type BearerToken_Body struct {
	// EACLTable carries table of extended ACL rules
	EaclTable *acl.EACLTable `protobuf:"bytes,1,opt,name=eacl_table,json=eaclTable,proto3" json:"eacl_table,omitempty"`
	// OwnerID carries identifier of the token owner
	OwnerId *refs.OwnerID `protobuf:"bytes,2,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Token expiration and valid time period parameters
	Lifetime             *TokenLifetime `protobuf:"bytes,3,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BearerToken_Body) Reset()         { *m = BearerToken_Body{} }
func (m *BearerToken_Body) String() string { return proto.CompactTextString(m) }
func (*BearerToken_Body) ProtoMessage()    {}
func (*BearerToken_Body) Descriptor() ([]byte, []int) {
	return fileDescriptor_932e020d69aee3f0, []int{4, 0}
}
func (m *BearerToken_Body) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerToken_Body) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerToken_Body.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerToken_Body) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerToken_Body.Merge(m, src)
}
func (m *BearerToken_Body) XXX_Size() int {
	return m.Size()
}
func (m *BearerToken_Body) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerToken_Body.DiscardUnknown(m)
}

var xxx_messageInfo_BearerToken_Body proto.InternalMessageInfo

func (m *BearerToken_Body) GetEaclTable() *acl.EACLTable {
	if m != nil {
		return m.EaclTable
	}
	return nil
}

func (m *BearerToken_Body) GetOwnerId() *refs.OwnerID {
	if m != nil {
		return m.OwnerId
	}
	return nil
}

func (m *BearerToken_Body) GetLifetime() *TokenLifetime {
	if m != nil {
		return m.Lifetime
	}
	return nil
}

// Information about the request
type RequestMetaHeader struct {
	// Client API version.
	Version *Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Client local epoch number. Set to 0 if unknown.
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// Maximum number of nodes in the request route.
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// Request X-Headers.
	XHeaders []*XHeader `protobuf:"bytes,4,rep,name=x_headers,json=xHeaders,proto3" json:"x_headers,omitempty"`
	// Token is a token of the session within which the request is sent
	Token *SessionToken `protobuf:"bytes,5,opt,name=token,proto3" json:"token,omitempty"`
	// Bearer is a Bearer token of the request
	Bearer *BearerToken `protobuf:"bytes,6,opt,name=bearer,proto3" json:"bearer,omitempty"`
	// RequestMetaHeader of the origin request.
	Origin               *RequestMetaHeader `protobuf:"bytes,7,opt,name=origin,proto3" json:"origin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RequestMetaHeader) Reset()         { *m = RequestMetaHeader{} }
func (m *RequestMetaHeader) String() string { return proto.CompactTextString(m) }
func (*RequestMetaHeader) ProtoMessage()    {}
func (*RequestMetaHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_932e020d69aee3f0, []int{5}
}
func (m *RequestMetaHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestMetaHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestMetaHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestMetaHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestMetaHeader.Merge(m, src)
}
func (m *RequestMetaHeader) XXX_Size() int {
	return m.Size()
}
func (m *RequestMetaHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestMetaHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestMetaHeader proto.InternalMessageInfo

func (m *RequestMetaHeader) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *RequestMetaHeader) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *RequestMetaHeader) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *RequestMetaHeader) GetXHeaders() []*XHeader {
	if m != nil {
		return m.XHeaders
	}
	return nil
}

func (m *RequestMetaHeader) GetToken() *SessionToken {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *RequestMetaHeader) GetBearer() *BearerToken {
	if m != nil {
		return m.Bearer
	}
	return nil
}

func (m *RequestMetaHeader) GetOrigin() *RequestMetaHeader {
	if m != nil {
		return m.Origin
	}
	return nil
}

// Information about the response
type ResponseMetaHeader struct {
	// Server API version.
	Version *Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Server local epoch number.
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// Maximum number of nodes in the response route.
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// Response X-Headers.
	XHeaders []*XHeader `protobuf:"bytes,4,rep,name=x_headers,json=xHeaders,proto3" json:"x_headers,omitempty"`
	// Carries response meta header of the origin response.
	Origin               *ResponseMetaHeader `protobuf:"bytes,5,opt,name=origin,proto3" json:"origin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ResponseMetaHeader) Reset()         { *m = ResponseMetaHeader{} }
func (m *ResponseMetaHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseMetaHeader) ProtoMessage()    {}
func (*ResponseMetaHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_932e020d69aee3f0, []int{6}
}
func (m *ResponseMetaHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseMetaHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseMetaHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseMetaHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseMetaHeader.Merge(m, src)
}
func (m *ResponseMetaHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseMetaHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseMetaHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseMetaHeader proto.InternalMessageInfo

func (m *ResponseMetaHeader) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *ResponseMetaHeader) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ResponseMetaHeader) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *ResponseMetaHeader) GetXHeaders() []*XHeader {
	if m != nil {
		return m.XHeaders
	}
	return nil
}

func (m *ResponseMetaHeader) GetOrigin() *ResponseMetaHeader {
	if m != nil {
		return m.Origin
	}
	return nil
}

func init() {
	proto.RegisterEnum("neo.fs.v2.service.SessionToken_Body_Verb", SessionToken_Body_Verb_name, SessionToken_Body_Verb_value)
	proto.RegisterType((*XHeader)(nil), "neo.fs.v2.service.XHeader")
	proto.RegisterType((*Version)(nil), "neo.fs.v2.service.Version")
	proto.RegisterType((*TokenLifetime)(nil), "neo.fs.v2.service.TokenLifetime")
	proto.RegisterType((*SessionToken)(nil), "neo.fs.v2.service.SessionToken")
	proto.RegisterType((*SessionToken_Body)(nil), "neo.fs.v2.service.SessionToken.Body")
	proto.RegisterType((*BearerToken)(nil), "neo.fs.v2.service.BearerToken")
	proto.RegisterType((*BearerToken_Body)(nil), "neo.fs.v2.service.BearerToken.Body")
	proto.RegisterType((*RequestMetaHeader)(nil), "neo.fs.v2.service.RequestMetaHeader")
	proto.RegisterType((*ResponseMetaHeader)(nil), "neo.fs.v2.service.ResponseMetaHeader")
}

func init() { proto.RegisterFile("v2/service/meta.proto", fileDescriptor_932e020d69aee3f0) }

var fileDescriptor_932e020d69aee3f0 = []byte{
	// 801 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x55, 0xcd, 0x8e, 0x1b, 0x45,
	0x10, 0xde, 0xb1, 0xc7, 0xf6, 0xba, 0xbc, 0x5e, 0x66, 0x9b, 0xa0, 0x58, 0x2b, 0xe4, 0xac, 0x0c,
	0x48, 0x20, 0xb1, 0x63, 0x61, 0x08, 0x11, 0x51, 0x22, 0x61, 0xef, 0x0e, 0xf1, 0xc2, 0x92, 0x44,
	0x6d, 0x13, 0x21, 0x2e, 0xd6, 0xfc, 0x94, 0x77, 0x27, 0xf1, 0x4e, 0x9b, 0xee, 0xde, 0xc1, 0x7e,
	0x00, 0xde, 0x81, 0x67, 0xe0, 0xc6, 0x8d, 0x0b, 0x57, 0xc4, 0x91, 0x1b, 0x57, 0xb4, 0xdc, 0x78,
	0x0a, 0xd4, 0x3f, 0x4e, 0x66, 0x89, 0x97, 0x3f, 0x71, 0xc8, 0xad, 0xea, 0xeb, 0xaa, 0xaf, 0xab,
	0xaa, 0xbf, 0xa9, 0x81, 0x57, 0xf2, 0x5e, 0x57, 0x20, 0xcf, 0xd3, 0x18, 0xbb, 0x67, 0x28, 0x43,
	0x7f, 0xce, 0x99, 0x64, 0x64, 0x27, 0x43, 0xe6, 0x4f, 0x85, 0x9f, 0xf7, 0x7c, 0x7b, 0xba, 0x4b,
	0xf2, 0x5e, 0x37, 0x8c, 0x67, 0x5d, 0xb9, 0x9c, 0xa3, 0x30, 0x61, 0xbb, 0x2f, 0xe7, 0xbd, 0x2e,
	0xc7, 0xa9, 0xb8, 0x04, 0x5e, 0x2f, 0x50, 0xe6, 0xc8, 0xd3, 0xe9, 0xd2, 0x1c, 0x74, 0xde, 0x81,
	0xda, 0xe7, 0x43, 0x0c, 0x13, 0xe4, 0xc4, 0x83, 0xf2, 0x13, 0x5c, 0xb6, 0x9c, 0x3d, 0xe7, 0xcd,
	0x3a, 0x55, 0x26, 0xb9, 0x06, 0x95, 0x3c, 0x9c, 0x9d, 0x63, 0xab, 0xa4, 0x31, 0xe3, 0x74, 0x6e,
	0x42, 0xed, 0x11, 0x72, 0x91, 0xb2, 0x4c, 0x05, 0x9c, 0x85, 0x8f, 0x19, 0xd7, 0x49, 0x4d, 0x6a,
	0x1c, 0x8d, 0xa6, 0x19, 0xe3, 0x3a, 0x4d, 0xa1, 0xca, 0xe9, 0x04, 0xd0, 0x1c, 0xb3, 0x27, 0x98,
	0x1d, 0xa7, 0x53, 0x94, 0xe9, 0x19, 0xaa, 0xfb, 0x70, 0x31, 0xd7, 0xa9, 0x2e, 0x55, 0xa6, 0x42,
	0xb2, 0x68, 0xaa, 0xd3, 0x5c, 0xaa, 0x4c, 0x85, 0xa4, 0xa1, 0x6c, 0x95, 0x0d, 0x92, 0x86, 0xb2,
	0xf3, 0xa3, 0x0b, 0x5b, 0x23, 0x14, 0xea, 0x7a, 0x4d, 0x47, 0x6e, 0x43, 0x45, 0x2a, 0x43, 0x13,
	0x35, 0x7a, 0xaf, 0xfb, 0xcf, 0x8d, 0xc9, 0x2f, 0xc6, 0xfb, 0x03, 0x96, 0x2c, 0xa9, 0x49, 0x21,
	0xb7, 0xa1, 0x2e, 0xd2, 0x93, 0x2c, 0x94, 0xe7, 0xdc, 0x34, 0xd9, 0xe8, 0xbd, 0xba, 0x2e, 0x7f,
	0x15, 0x43, 0x9f, 0x85, 0xef, 0xfe, 0x50, 0x06, 0x57, 0x71, 0x91, 0x6d, 0x28, 0xa5, 0x89, 0xbe,
	0x7d, 0x8b, 0x96, 0xd2, 0x84, 0xf4, 0x60, 0x93, 0x7d, 0x95, 0x21, 0x9f, 0xa4, 0x89, 0xe5, 0xbc,
	0x5e, 0xe0, 0x54, 0x4f, 0xe3, 0x3f, 0x50, 0xe7, 0x47, 0x87, 0xb4, 0xa6, 0x03, 0x8f, 0x12, 0x72,
	0x17, 0xdc, 0x1c, 0x79, 0xa4, 0x1b, 0xdd, 0xee, 0xbd, 0xf5, 0x4f, 0x7a, 0xf0, 0x1f, 0x21, 0x8f,
	0xa8, 0x4e, 0x23, 0x77, 0x60, 0x73, 0x66, 0xc7, 0xda, 0x72, 0xf5, 0x95, 0x7b, 0x6b, 0x28, 0x2e,
	0x8d, 0x9f, 0x3e, 0xcd, 0x20, 0x37, 0xa0, 0x21, 0x0c, 0xfb, 0x44, 0x09, 0xa0, 0xa2, 0x3b, 0x01,
	0x0b, 0x7d, 0x82, 0x4b, 0xf2, 0x21, 0x6c, 0xb3, 0xe8, 0x31, 0xc6, 0x72, 0x12, 0x26, 0x09, 0x47,
	0x21, 0x5a, 0xd5, 0xf5, 0x7d, 0xf5, 0xcd, 0xf1, 0x70, 0x83, 0x36, 0x4d, 0x82, 0x05, 0x3a, 0x5f,
	0x3b, 0xe0, 0xaa, 0x7a, 0xc9, 0x36, 0xc0, 0x83, 0xc1, 0xc7, 0xc1, 0xc1, 0x78, 0xf2, 0xf0, 0xb3,
	0xb1, 0xb7, 0x51, 0xf0, 0xef, 0x05, 0x63, 0xcf, 0x21, 0x2f, 0x41, 0xc3, 0xfa, 0xc3, 0xa0, 0x7f,
	0xe8, 0x95, 0xc8, 0x0e, 0x34, 0x2d, 0x30, 0x0a, 0xfa, 0xf4, 0x60, 0xe8, 0x95, 0x0b, 0xd0, 0x61,
	0x70, 0x1c, 0x8c, 0x03, 0xcf, 0x25, 0x1e, 0x6c, 0x59, 0x88, 0xf6, 0xef, 0xdf, 0x0b, 0xbc, 0x0a,
	0xb9, 0x06, 0x5e, 0x11, 0x19, 0xf6, 0x47, 0x43, 0xaf, 0x3a, 0xa8, 0x43, 0x2d, 0x66, 0x99, 0xc4,
	0x85, 0xec, 0x7c, 0x5f, 0x82, 0xc6, 0x00, 0x43, 0x8e, 0xdc, 0xe8, 0xe8, 0x83, 0xcb, 0x3a, 0x7a,
	0x6d, 0xcd, 0x00, 0x0b, 0xe1, 0xff, 0x9b, 0x8c, 0xbe, 0x73, 0xac, 0x8c, 0x6e, 0x01, 0x60, 0x18,
	0xcf, 0x26, 0x32, 0x8c, 0x66, 0x68, 0x8b, 0x68, 0x15, 0x58, 0xc2, 0x78, 0xe6, 0x07, 0xfd, 0x83,
	0xe3, 0xb1, 0x3a, 0xa7, 0x75, 0x15, 0xab, 0xcd, 0xff, 0xa4, 0xb7, 0xa2, 0x60, 0xca, 0xff, 0x56,
	0x30, 0x9d, 0x5f, 0x4a, 0xb0, 0x43, 0xf1, 0xcb, 0x73, 0x14, 0xf2, 0x53, 0x94, 0xa1, 0xdd, 0x1f,
	0xef, 0x41, 0x2d, 0x37, 0x7b, 0xc1, 0x56, 0xbf, 0xbb, 0x86, 0xd2, 0x6e, 0x0e, 0xba, 0x0a, 0x55,
	0xcb, 0x02, 0xe7, 0x2c, 0x3e, 0xb5, 0x5f, 0xbd, 0x71, 0xd4, 0x77, 0x2f, 0xe5, 0x4c, 0x97, 0xd6,
	0xa4, 0xca, 0x24, 0xb7, 0xa0, 0xbe, 0x98, 0x9c, 0xea, 0x9b, 0x44, 0xcb, 0xdd, 0x2b, 0x5f, 0xc1,
	0x6f, 0x97, 0x19, 0xdd, 0x5c, 0x18, 0x43, 0x90, 0x9b, 0xab, 0x77, 0xad, 0xe8, 0xa2, 0x6e, 0xfc,
	0xcd, 0xb7, 0xb5, 0x7a, 0xd3, 0xf7, 0xa1, 0x1a, 0xe9, 0xe7, 0xb6, 0x5a, 0x6f, 0xff, 0xb5, 0x1e,
	0xa8, 0x8d, 0x26, 0x77, 0xa0, 0xca, 0x78, 0x7a, 0x92, 0x66, 0xad, 0xda, 0x95, 0xfb, 0xe8, 0xb9,
	0xd9, 0x51, 0x9b, 0xd3, 0xf9, 0xdd, 0x01, 0x42, 0x51, 0xcc, 0x59, 0x26, 0xf0, 0xc5, 0x1f, 0xed,
	0xdd, 0xa7, 0xbd, 0x9a, 0xd9, 0xbe, 0xb1, 0xb6, 0xd7, 0x3f, 0x77, 0xb3, 0x6a, 0x76, 0x40, 0x7f,
	0xba, 0x68, 0x3b, 0x3f, 0x5f, 0xb4, 0x9d, 0x5f, 0x2f, 0xda, 0xce, 0x37, 0xbf, 0xb5, 0x37, 0xbe,
	0x78, 0xfb, 0x24, 0x95, 0xa7, 0xe7, 0x91, 0x1f, 0xb3, 0xb3, 0x6e, 0x26, 0xe6, 0x71, 0xbc, 0x9f,
	0x60, 0xde, 0xcd, 0x90, 0x4d, 0xc5, 0x7e, 0x38, 0x4f, 0xf7, 0x4f, 0x58, 0xf7, 0xd9, 0x8f, 0xec,
	0xdb, 0xd2, 0xce, 0x7d, 0x64, 0x1f, 0x8d, 0xfc, 0xfe, 0xc3, 0x23, 0x7f, 0x64, 0xb0, 0xa8, 0xaa,
	0x7f, 0x6b, 0xef, 0xfe, 0x11, 0x00, 0x00, 0xff, 0xff, 0x1a, 0xf8, 0x0e, 0x53, 0x44, 0x07, 0x00,
	0x00,
}

func (m *XHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *XHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Version) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Minor != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Minor))
		i--
		dAtA[i] = 0x10
	}
	if m.Major != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Major))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TokenLifetime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenLifetime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenLifetime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Iat != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Iat))
		i--
		dAtA[i] = 0x18
	}
	if m.Nbf != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Nbf))
		i--
		dAtA[i] = 0x10
	}
	if m.Exp != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Exp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionToken_Body) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionToken_Body) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionToken_Body) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Context != nil {
		{
			size := m.Context.Size()
			i -= size
			if _, err := m.Context.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SessionKey) > 0 {
		i -= len(m.SessionKey)
		copy(dAtA[i:], m.SessionKey)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.SessionKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Lifetime != nil {
		{
			size, err := m.Lifetime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Verb != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Verb))
		i--
		dAtA[i] = 0x18
	}
	if m.OwnerId != nil {
		{
			size, err := m.OwnerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionToken_Body_ObjectAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionToken_Body_ObjectAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ObjectAddress != nil {
		{
			size, err := m.ObjectAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *BearerToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerToken_Body) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerToken_Body) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerToken_Body) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lifetime != nil {
		{
			size, err := m.Lifetime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.OwnerId != nil {
		{
			size, err := m.OwnerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EaclTable != nil {
		{
			size, err := m.EaclTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestMetaHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestMetaHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestMetaHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Origin != nil {
		{
			size, err := m.Origin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Bearer != nil {
		{
			size, err := m.Bearer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.XHeaders) > 0 {
		for iNdEx := len(m.XHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.XHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Ttl != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Ttl))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseMetaHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseMetaHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseMetaHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Origin != nil {
		{
			size, err := m.Origin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.XHeaders) > 0 {
		for iNdEx := len(m.XHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.XHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Ttl != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Ttl))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMeta(dAtA []byte, offset int, v uint64) int {
	offset -= sovMeta(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *XHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Major != 0 {
		n += 1 + sovMeta(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovMeta(uint64(m.Minor))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TokenLifetime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exp != 0 {
		n += 1 + sovMeta(uint64(m.Exp))
	}
	if m.Nbf != 0 {
		n += 1 + sovMeta(uint64(m.Nbf))
	}
	if m.Iat != 0 {
		n += 1 + sovMeta(uint64(m.Iat))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionToken_Body) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.OwnerId != nil {
		l = m.OwnerId.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Verb != 0 {
		n += 1 + sovMeta(uint64(m.Verb))
	}
	if m.Lifetime != nil {
		l = m.Lifetime.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.SessionKey)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Context != nil {
		n += m.Context.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionToken_Body_ObjectAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectAddress != nil {
		l = m.ObjectAddress.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}
func (m *BearerToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BearerToken_Body) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EaclTable != nil {
		l = m.EaclTable.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.OwnerId != nil {
		l = m.OwnerId.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Lifetime != nil {
		l = m.Lifetime.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestMetaHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMeta(uint64(m.Epoch))
	}
	if m.Ttl != 0 {
		n += 1 + sovMeta(uint64(m.Ttl))
	}
	if len(m.XHeaders) > 0 {
		for _, e := range m.XHeaders {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Bearer != nil {
		l = m.Bearer.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseMetaHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMeta(uint64(m.Epoch))
	}
	if m.Ttl != 0 {
		n += 1 + sovMeta(uint64(m.Ttl))
	}
	if len(m.XHeaders) > 0 {
		for _, e := range m.XHeaders {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMeta(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMeta(x uint64) (n int) {
	return sovMeta(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *XHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenLifetime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenLifetime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenLifetime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbf", wireType)
			}
			m.Nbf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbf |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iat", wireType)
			}
			m.Iat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &SessionToken_Body{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionToken_Body) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Body: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Body: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerId == nil {
				m.OwnerId = &refs.OwnerID{}
			}
			if err := m.OwnerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verb", wireType)
			}
			m.Verb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Verb |= SessionToken_Body_Verb(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lifetime == nil {
				m.Lifetime = &TokenLifetime{}
			}
			if err := m.Lifetime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionKey = append(m.SessionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionKey == nil {
				m.SessionKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &refs.Address{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Context = &SessionToken_Body_ObjectAddress{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &BearerToken_Body{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerToken_Body) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Body: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Body: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EaclTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EaclTable == nil {
				m.EaclTable = &acl.EACLTable{}
			}
			if err := m.EaclTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerId == nil {
				m.OwnerId = &refs.OwnerID{}
			}
			if err := m.OwnerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lifetime == nil {
				m.Lifetime = &TokenLifetime{}
			}
			if err := m.Lifetime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestMetaHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestMetaHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestMetaHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XHeaders = append(m.XHeaders, &XHeader{})
			if err := m.XHeaders[len(m.XHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &SessionToken{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bearer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bearer == nil {
				m.Bearer = &BearerToken{}
			}
			if err := m.Bearer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &RequestMetaHeader{}
			}
			if err := m.Origin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseMetaHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseMetaHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseMetaHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XHeaders = append(m.XHeaders, &XHeader{})
			if err := m.XHeaders[len(m.XHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &ResponseMetaHeader{}
			}
			if err := m.Origin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMeta(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMeta
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMeta
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMeta
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMeta        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMeta          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMeta = fmt.Errorf("proto: unexpected end of group")
)
