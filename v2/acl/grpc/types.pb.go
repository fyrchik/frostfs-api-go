// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v2/acl/grpc/types.proto

package acl

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "github.com/nspcc-dev/neofs-api-go/v2/refs/grpc"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Target of the access control rule in access control list.
type Target int32

const (
	// Unspecified target, default value.
	Target_TARGET_UNSPECIFIED Target = 0
	// User target rule is applied if sender is the owner of the container.
	Target_USER Target = 1
	// System target rule is applied if sender is the storage node within the
	// container or inner ring node.
	Target_SYSTEM Target = 2
	// Others target rule is applied if sender is not user or system target.
	Target_OTHERS Target = 3
)

var Target_name = map[int32]string{
	0: "TARGET_UNSPECIFIED",
	1: "USER",
	2: "SYSTEM",
	3: "OTHERS",
}

var Target_value = map[string]int32{
	"TARGET_UNSPECIFIED": 0,
	"USER":               1,
	"SYSTEM":             2,
	"OTHERS":             3,
}

func (x Target) String() string {
	return proto.EnumName(Target_name, int32(x))
}

func (Target) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0}
}

// Operation is an enumeration of operation types.
type EACLRecord_Operation int32

const (
	// Unspecified operation, default value.
	EACLRecord_OPERATION_UNSPECIFIED EACLRecord_Operation = 0
	// Get
	EACLRecord_GET EACLRecord_Operation = 1
	// Head
	EACLRecord_HEAD EACLRecord_Operation = 2
	// Put
	EACLRecord_PUT EACLRecord_Operation = 3
	// Delete
	EACLRecord_DELETE EACLRecord_Operation = 4
	// Search
	EACLRecord_SEARCH EACLRecord_Operation = 5
	// GetRange
	EACLRecord_GETRANGE EACLRecord_Operation = 6
	// GetRangeHash
	EACLRecord_GETRANGEHASH EACLRecord_Operation = 7
)

var EACLRecord_Operation_name = map[int32]string{
	0: "OPERATION_UNSPECIFIED",
	1: "GET",
	2: "HEAD",
	3: "PUT",
	4: "DELETE",
	5: "SEARCH",
	6: "GETRANGE",
	7: "GETRANGEHASH",
}

var EACLRecord_Operation_value = map[string]int32{
	"OPERATION_UNSPECIFIED": 0,
	"GET":                   1,
	"HEAD":                  2,
	"PUT":                   3,
	"DELETE":                4,
	"SEARCH":                5,
	"GETRANGE":              6,
	"GETRANGEHASH":          7,
}

func (x EACLRecord_Operation) String() string {
	return proto.EnumName(EACLRecord_Operation_name, int32(x))
}

func (EACLRecord_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0, 0}
}

// Action is an enumeration of EACL actions.
type EACLRecord_Action int32

const (
	// Unspecified action, default value.
	EACLRecord_ACTION_UNSPECIFIED EACLRecord_Action = 0
	// Allow action
	EACLRecord_ALLOW EACLRecord_Action = 1
	// Deny action
	EACLRecord_DENY EACLRecord_Action = 2
)

var EACLRecord_Action_name = map[int32]string{
	0: "ACTION_UNSPECIFIED",
	1: "ALLOW",
	2: "DENY",
}

var EACLRecord_Action_value = map[string]int32{
	"ACTION_UNSPECIFIED": 0,
	"ALLOW":              1,
	"DENY":               2,
}

func (x EACLRecord_Action) String() string {
	return proto.EnumName(EACLRecord_Action_name, int32(x))
}

func (EACLRecord_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0, 1}
}

// Header is an enumeration of filtering header types.
type EACLRecord_FilterInfo_Header int32

const (
	// Unspecified header, default value.
	EACLRecord_FilterInfo_HEADER_UNSPECIFIED EACLRecord_FilterInfo_Header = 0
	// Filter request headers
	EACLRecord_FilterInfo_REQUEST EACLRecord_FilterInfo_Header = 1
	// Filter object headers
	EACLRecord_FilterInfo_OBJECT EACLRecord_FilterInfo_Header = 2
)

var EACLRecord_FilterInfo_Header_name = map[int32]string{
	0: "HEADER_UNSPECIFIED",
	1: "REQUEST",
	2: "OBJECT",
}

var EACLRecord_FilterInfo_Header_value = map[string]int32{
	"HEADER_UNSPECIFIED": 0,
	"REQUEST":            1,
	"OBJECT":             2,
}

func (x EACLRecord_FilterInfo_Header) String() string {
	return proto.EnumName(EACLRecord_FilterInfo_Header_name, int32(x))
}

func (EACLRecord_FilterInfo_Header) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0, 0, 0}
}

// MatchType is an enumeration of match types.
type EACLRecord_FilterInfo_MatchType int32

const (
	// Unspecified match type, default value.
	EACLRecord_FilterInfo_MATCH_TYPE_UNSPECIFIED EACLRecord_FilterInfo_MatchType = 0
	// Return true if strings are equal
	EACLRecord_FilterInfo_STRING_EQUAL EACLRecord_FilterInfo_MatchType = 1
	// Return true if strings are different
	EACLRecord_FilterInfo_STRING_NOT_EQUAL EACLRecord_FilterInfo_MatchType = 2
)

var EACLRecord_FilterInfo_MatchType_name = map[int32]string{
	0: "MATCH_TYPE_UNSPECIFIED",
	1: "STRING_EQUAL",
	2: "STRING_NOT_EQUAL",
}

var EACLRecord_FilterInfo_MatchType_value = map[string]int32{
	"MATCH_TYPE_UNSPECIFIED": 0,
	"STRING_EQUAL":           1,
	"STRING_NOT_EQUAL":       2,
}

func (x EACLRecord_FilterInfo_MatchType) String() string {
	return proto.EnumName(EACLRecord_FilterInfo_MatchType_name, int32(x))
}

func (EACLRecord_FilterInfo_MatchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0, 0, 1}
}

// EACLRecord groups information about extended ACL rule.
type EACLRecord struct {
	// Operation carries type of operation.
	Operation EACLRecord_Operation `protobuf:"varint,1,opt,name=operation,json=Operation,proto3,enum=neo.fs.v2.acl.EACLRecord_Operation" json:"operation,omitempty"`
	// Action carries ACL target action.
	Action EACLRecord_Action `protobuf:"varint,2,opt,name=action,json=Action,proto3,enum=neo.fs.v2.acl.EACLRecord_Action" json:"action,omitempty"`
	// filters carries set of filters.
	Filters []*EACLRecord_FilterInfo `protobuf:"bytes,3,rep,name=filters,json=Filters,proto3" json:"filters,omitempty"`
	// targets carries information about extended ACL target list.
	Targets              []*EACLRecord_TargetInfo `protobuf:"bytes,4,rep,name=targets,json=Targets,proto3" json:"targets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *EACLRecord) Reset()         { *m = EACLRecord{} }
func (m *EACLRecord) String() string { return proto.CompactTextString(m) }
func (*EACLRecord) ProtoMessage()    {}
func (*EACLRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0}
}
func (m *EACLRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLRecord.Merge(m, src)
}
func (m *EACLRecord) XXX_Size() int {
	return m.Size()
}
func (m *EACLRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLRecord.DiscardUnknown(m)
}

var xxx_messageInfo_EACLRecord proto.InternalMessageInfo

func (m *EACLRecord) GetOperation() EACLRecord_Operation {
	if m != nil {
		return m.Operation
	}
	return EACLRecord_OPERATION_UNSPECIFIED
}

func (m *EACLRecord) GetAction() EACLRecord_Action {
	if m != nil {
		return m.Action
	}
	return EACLRecord_ACTION_UNSPECIFIED
}

func (m *EACLRecord) GetFilters() []*EACLRecord_FilterInfo {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *EACLRecord) GetTargets() []*EACLRecord_TargetInfo {
	if m != nil {
		return m.Targets
	}
	return nil
}

// FilterInfo groups information about filter.
type EACLRecord_FilterInfo struct {
	// Header carries type of header.
	Header EACLRecord_FilterInfo_Header `protobuf:"varint,1,opt,name=header,json=HeaderType,proto3,enum=neo.fs.v2.acl.EACLRecord_FilterInfo_Header" json:"header,omitempty"`
	// MatchType carries type of match.
	MatchType EACLRecord_FilterInfo_MatchType `protobuf:"varint,2,opt,name=match_type,json=MatchType,proto3,enum=neo.fs.v2.acl.EACLRecord_FilterInfo_MatchType" json:"match_type,omitempty"`
	// header_name carries name of filtering header.
	HeaderName string `protobuf:"bytes,3,opt,name=header_name,json=Name,proto3" json:"header_name,omitempty"`
	// header_val carries value of filtering header.
	HeaderVal            string   `protobuf:"bytes,4,opt,name=header_val,json=Value,proto3" json:"header_val,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EACLRecord_FilterInfo) Reset()         { *m = EACLRecord_FilterInfo{} }
func (m *EACLRecord_FilterInfo) String() string { return proto.CompactTextString(m) }
func (*EACLRecord_FilterInfo) ProtoMessage()    {}
func (*EACLRecord_FilterInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0, 0}
}
func (m *EACLRecord_FilterInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLRecord_FilterInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLRecord_FilterInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLRecord_FilterInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLRecord_FilterInfo.Merge(m, src)
}
func (m *EACLRecord_FilterInfo) XXX_Size() int {
	return m.Size()
}
func (m *EACLRecord_FilterInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLRecord_FilterInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EACLRecord_FilterInfo proto.InternalMessageInfo

func (m *EACLRecord_FilterInfo) GetHeader() EACLRecord_FilterInfo_Header {
	if m != nil {
		return m.Header
	}
	return EACLRecord_FilterInfo_HEADER_UNSPECIFIED
}

func (m *EACLRecord_FilterInfo) GetMatchType() EACLRecord_FilterInfo_MatchType {
	if m != nil {
		return m.MatchType
	}
	return EACLRecord_FilterInfo_MATCH_TYPE_UNSPECIFIED
}

func (m *EACLRecord_FilterInfo) GetHeaderName() string {
	if m != nil {
		return m.HeaderName
	}
	return ""
}

func (m *EACLRecord_FilterInfo) GetHeaderVal() string {
	if m != nil {
		return m.HeaderVal
	}
	return ""
}

// TargetInfo groups information about extended ACL target.
type EACLRecord_TargetInfo struct {
	// target carries target of ACL rule.
	Target Target `protobuf:"varint,1,opt,name=target,json=Role,proto3,enum=neo.fs.v2.acl.Target" json:"target,omitempty"`
	// key_list carries public keys of ACL target.
	KeyList              [][]byte `protobuf:"bytes,2,rep,name=key_list,json=Keys,proto3" json:"key_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EACLRecord_TargetInfo) Reset()         { *m = EACLRecord_TargetInfo{} }
func (m *EACLRecord_TargetInfo) String() string { return proto.CompactTextString(m) }
func (*EACLRecord_TargetInfo) ProtoMessage()    {}
func (*EACLRecord_TargetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0, 1}
}
func (m *EACLRecord_TargetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLRecord_TargetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLRecord_TargetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLRecord_TargetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLRecord_TargetInfo.Merge(m, src)
}
func (m *EACLRecord_TargetInfo) XXX_Size() int {
	return m.Size()
}
func (m *EACLRecord_TargetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLRecord_TargetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EACLRecord_TargetInfo proto.InternalMessageInfo

func (m *EACLRecord_TargetInfo) GetTarget() Target {
	if m != nil {
		return m.Target
	}
	return Target_TARGET_UNSPECIFIED
}

func (m *EACLRecord_TargetInfo) GetKeyList() [][]byte {
	if m != nil {
		return m.KeyList
	}
	return nil
}

// EACLRecord carries the information about extended ACL rules.
type EACLTable struct {
	// Carries identifier of the container that should use given
	// access control rules.
	ContainerId *grpc.ContainerID `protobuf:"bytes,1,opt,name=container_id,json=ContainerID,proto3" json:"container_id,omitempty"`
	// Records carries list of extended ACL rule records.
	Records              []*EACLRecord `protobuf:"bytes,2,rep,name=records,json=Records,proto3" json:"records,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *EACLTable) Reset()         { *m = EACLTable{} }
func (m *EACLTable) String() string { return proto.CompactTextString(m) }
func (*EACLTable) ProtoMessage()    {}
func (*EACLTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{1}
}
func (m *EACLTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLTable.Merge(m, src)
}
func (m *EACLTable) XXX_Size() int {
	return m.Size()
}
func (m *EACLTable) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLTable.DiscardUnknown(m)
}

var xxx_messageInfo_EACLTable proto.InternalMessageInfo

func (m *EACLTable) GetContainerId() *grpc.ContainerID {
	if m != nil {
		return m.ContainerId
	}
	return nil
}

func (m *EACLTable) GetRecords() []*EACLRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

func init() {
	proto.RegisterEnum("neo.fs.v2.acl.Target", Target_name, Target_value)
	proto.RegisterEnum("neo.fs.v2.acl.EACLRecord_Operation", EACLRecord_Operation_name, EACLRecord_Operation_value)
	proto.RegisterEnum("neo.fs.v2.acl.EACLRecord_Action", EACLRecord_Action_name, EACLRecord_Action_value)
	proto.RegisterEnum("neo.fs.v2.acl.EACLRecord_FilterInfo_Header", EACLRecord_FilterInfo_Header_name, EACLRecord_FilterInfo_Header_value)
	proto.RegisterEnum("neo.fs.v2.acl.EACLRecord_FilterInfo_MatchType", EACLRecord_FilterInfo_MatchType_name, EACLRecord_FilterInfo_MatchType_value)
	proto.RegisterType((*EACLRecord)(nil), "neo.fs.v2.acl.EACLRecord")
	proto.RegisterType((*EACLRecord_FilterInfo)(nil), "neo.fs.v2.acl.EACLRecord.FilterInfo")
	proto.RegisterType((*EACLRecord_TargetInfo)(nil), "neo.fs.v2.acl.EACLRecord.TargetInfo")
	proto.RegisterType((*EACLTable)(nil), "neo.fs.v2.acl.EACLTable")
}

func init() { proto.RegisterFile("v2/acl/grpc/types.proto", fileDescriptor_8233b6696fb3e24f) }

var fileDescriptor_8233b6696fb3e24f = []byte{
	// 710 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xd1, 0x6e, 0xda, 0x3a,
	0x18, 0x6e, 0x42, 0x1a, 0xe0, 0x87, 0x73, 0x64, 0x59, 0xa7, 0x1c, 0xca, 0x91, 0x10, 0xe2, 0xec,
	0x02, 0xad, 0x6a, 0xd0, 0xa8, 0x26, 0x6d, 0x9a, 0x54, 0x29, 0x05, 0x17, 0xd8, 0x20, 0x50, 0xc7,
	0x74, 0xea, 0x6e, 0x50, 0x1a, 0x0c, 0x45, 0x0b, 0x09, 0x4a, 0x52, 0x24, 0x76, 0xb5, 0xc7, 0xd8,
	0x33, 0xec, 0x49, 0x76, 0xb9, 0x47, 0x98, 0x3a, 0x69, 0xcf, 0xb0, 0xcb, 0xc9, 0x09, 0xb4, 0x8c,
	0xad, 0x5a, 0xaf, 0xfc, 0xc7, 0xfe, 0xbe, 0xdf, 0x9f, 0x3f, 0x7f, 0x31, 0xfc, 0xbb, 0xa8, 0x55,
	0x2d, 0xdb, 0xa9, 0x4e, 0xfc, 0xb9, 0x5d, 0x0d, 0x97, 0x73, 0x1e, 0x68, 0x73, 0xdf, 0x0b, 0x3d,
	0xfc, 0x97, 0xcb, 0x3d, 0x6d, 0x1c, 0x68, 0x8b, 0x9a, 0x66, 0xd9, 0x4e, 0x21, 0xbf, 0xa8, 0x55,
	0x7d, 0x3e, 0x0e, 0x7e, 0x01, 0x96, 0xbf, 0xab, 0x00, 0x44, 0xaf, 0x77, 0x28, 0xb7, 0x3d, 0x7f,
	0x84, 0x75, 0x48, 0x7b, 0x73, 0xee, 0x5b, 0xe1, 0xd4, 0x73, 0xf3, 0x52, 0x49, 0xaa, 0xfc, 0x5d,
	0xfb, 0x5f, 0xfb, 0xa9, 0x97, 0x76, 0x87, 0xd6, 0x7a, 0x6b, 0x28, 0x4d, 0xdf, 0x96, 0xf8, 0x19,
	0xa8, 0x96, 0x1d, 0xf1, 0xe5, 0x88, 0x5f, 0xba, 0x9f, 0xaf, 0x47, 0x38, 0xaa, 0xc6, 0x23, 0x3e,
	0x86, 0xe4, 0x78, 0xea, 0x84, 0xdc, 0x0f, 0xf2, 0x89, 0x52, 0xa2, 0x92, 0xa9, 0x3d, 0xba, 0x9f,
	0x7a, 0x1a, 0x01, 0xdb, 0xee, 0xd8, 0xa3, 0xc9, 0xb8, 0x0e, 0x04, 0x3f, 0xb4, 0xfc, 0x09, 0x0f,
	0x83, 0xbc, 0xf2, 0x27, 0x3e, 0x8b, 0x80, 0x31, 0x3f, 0xae, 0x83, 0xc2, 0x37, 0x19, 0xe0, 0xae,
	0x2f, 0x6e, 0x82, 0x7a, 0xc5, 0xad, 0x11, 0xf7, 0x57, 0x46, 0x1c, 0x3c, 0x44, 0x8d, 0xd6, 0x8a,
	0x28, 0x14, 0xe2, 0x91, 0x2d, 0xe7, 0x1c, 0x77, 0x01, 0x66, 0x56, 0x68, 0x5f, 0x0d, 0x85, 0xf1,
	0x2b, 0x57, 0xb4, 0x07, 0x35, 0xeb, 0x0a, 0x9a, 0xe8, 0x41, 0xd3, 0xb7, 0x25, 0xde, 0x87, 0x4c,
	0xac, 0x6b, 0xe8, 0x5a, 0x33, 0x9e, 0x4f, 0x94, 0xa4, 0x4a, 0x9a, 0x2a, 0x86, 0x35, 0x13, 0x4b,
	0xb0, 0x5a, 0x5a, 0x58, 0x4e, 0x5e, 0x89, 0x56, 0x76, 0xcf, 0x2d, 0xe7, 0x9a, 0x97, 0x9f, 0x83,
	0x1a, 0x4b, 0xc2, 0x39, 0xc0, 0x2d, 0xa2, 0x37, 0x08, 0x1d, 0x0e, 0x0c, 0xb3, 0x4f, 0xea, 0xed,
	0xd3, 0x36, 0x69, 0xa0, 0x1d, 0x9c, 0x81, 0x24, 0x25, 0x67, 0x03, 0x62, 0x32, 0x24, 0x61, 0x00,
	0xb5, 0x77, 0xf2, 0x92, 0xd4, 0x19, 0x92, 0xcb, 0x3d, 0xd8, 0xd8, 0xbd, 0x00, 0xb9, 0xae, 0xce,
	0xea, 0xad, 0x21, 0xbb, 0xe8, 0x93, 0xad, 0x0e, 0x08, 0xb2, 0x26, 0xa3, 0x6d, 0xa3, 0x39, 0x24,
	0x67, 0x03, 0xbd, 0x83, 0x24, 0xfc, 0x0f, 0xa0, 0xd5, 0x8c, 0xd1, 0x63, 0xab, 0x59, 0xb9, 0x70,
	0x06, 0x70, 0xe7, 0x3f, 0x3e, 0x00, 0x35, 0xbe, 0xb6, 0x95, 0xcf, 0x7b, 0x5b, 0xd6, 0xc4, 0x50,
	0xaa, 0x50, 0xcf, 0xe1, 0x38, 0x07, 0xa9, 0xb7, 0x7c, 0x39, 0x74, 0xa6, 0x41, 0x98, 0x97, 0x4b,
	0x89, 0x4a, 0x96, 0x2a, 0xaf, 0xf8, 0x32, 0x28, 0xbf, 0x83, 0x8d, 0x08, 0xee, 0xc3, 0x5e, 0xaf,
	0x4f, 0xa8, 0xce, 0xda, 0x3d, 0x63, 0x4b, 0x62, 0x12, 0x12, 0x4d, 0x22, 0x0e, 0x98, 0x02, 0x45,
	0xb8, 0x80, 0x64, 0x31, 0xd5, 0x1f, 0x30, 0x94, 0x10, 0x67, 0x6e, 0x90, 0x0e, 0x61, 0x04, 0x29,
	0xa2, 0x36, 0x89, 0x4e, 0xeb, 0x2d, 0xb4, 0x8b, 0xb3, 0x90, 0x6a, 0x12, 0x46, 0x75, 0xa3, 0x49,
	0x90, 0x2a, 0x0e, 0xb9, 0xfe, 0x6a, 0xe9, 0x66, 0x0b, 0x25, 0xcb, 0x4f, 0x61, 0x9d, 0xe0, 0x1c,
	0x60, 0xbd, 0xfe, 0x9b, 0x5d, 0xd3, 0xb0, 0xab, 0x77, 0x3a, 0xbd, 0xd7, 0xf1, 0xbe, 0x0d, 0x62,
	0x5c, 0x20, 0xb9, 0xfc, 0x5e, 0x82, 0xb4, 0xb8, 0x76, 0x66, 0x5d, 0x3a, 0x1c, 0x1f, 0x43, 0xd6,
	0xf6, 0xdc, 0xd0, 0x9a, 0xba, 0xdc, 0x1f, 0x4e, 0x47, 0x91, 0x17, 0x99, 0xda, 0x7f, 0x1b, 0x5e,
	0x88, 0x1f, 0x58, 0xab, 0xaf, 0x31, 0xed, 0x06, 0xcd, 0x6c, 0x7c, 0xe0, 0x23, 0x48, 0xfa, 0x51,
	0x7e, 0x82, 0xc8, 0x97, 0x4c, 0x6d, 0xff, 0xde, 0x84, 0xd1, 0x64, 0x3c, 0x06, 0x8f, 0x4f, 0x40,
	0x8d, 0xdd, 0x15, 0xca, 0x99, 0x4e, 0x9b, 0x84, 0x6d, 0x29, 0x4f, 0x81, 0x32, 0x30, 0x09, 0x8d,
	0x13, 0x61, 0x5e, 0x98, 0x8c, 0x74, 0x91, 0x1c, 0xa5, 0x83, 0xb5, 0x08, 0x35, 0x51, 0xe2, 0xe4,
	0xfc, 0xd3, 0x4d, 0x51, 0xfa, 0x7c, 0x53, 0x94, 0xbe, 0xdc, 0x14, 0xa5, 0x0f, 0x5f, 0x8b, 0x3b,
	0x6f, 0x9e, 0x4c, 0xa6, 0xe1, 0xd5, 0xf5, 0xa5, 0x66, 0x7b, 0xb3, 0xaa, 0x1b, 0xcc, 0x6d, 0xfb,
	0x70, 0xc4, 0x17, 0x55, 0x97, 0x7b, 0xe3, 0xe0, 0xd0, 0x9a, 0x4f, 0x0f, 0x27, 0x5e, 0x75, 0xe3,
	0xdd, 0x7a, 0x61, 0xd9, 0xce, 0x47, 0x19, 0x19, 0xdc, 0x3b, 0x35, 0x35, 0xbd, 0xdf, 0x16, 0x7a,
	0x75, 0xdb, 0xb9, 0x54, 0xa3, 0x07, 0xea, 0xe8, 0x47, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf6, 0x1c,
	0x01, 0xad, 0xe4, 0x04, 0x00, 0x00,
}

func (m *EACLRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x10
	}
	if m.Operation != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EACLRecord_FilterInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLRecord_FilterInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLRecord_FilterInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HeaderVal) > 0 {
		i -= len(m.HeaderVal)
		copy(dAtA[i:], m.HeaderVal)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HeaderVal)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HeaderName) > 0 {
		i -= len(m.HeaderName)
		copy(dAtA[i:], m.HeaderName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HeaderName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MatchType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MatchType))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Header))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EACLRecord_TargetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLRecord_TargetInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLRecord_TargetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KeyList) > 0 {
		for iNdEx := len(m.KeyList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyList[iNdEx])
			copy(dAtA[i:], m.KeyList[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.KeyList[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Target != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Target))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EACLTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ContainerId != nil {
		{
			size, err := m.ContainerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EACLRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovTypes(uint64(m.Operation))
	}
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EACLRecord_FilterInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != 0 {
		n += 1 + sovTypes(uint64(m.Header))
	}
	if m.MatchType != 0 {
		n += 1 + sovTypes(uint64(m.MatchType))
	}
	l = len(m.HeaderName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HeaderVal)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EACLRecord_TargetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != 0 {
		n += 1 + sovTypes(uint64(m.Target))
	}
	if len(m.KeyList) > 0 {
		for _, b := range m.KeyList {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EACLTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerId != nil {
		l = m.ContainerId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EACLRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EACLRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EACLRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= EACLRecord_Operation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= EACLRecord_Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &EACLRecord_FilterInfo{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, &EACLRecord_TargetInfo{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EACLRecord_FilterInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			m.Header = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Header |= EACLRecord_FilterInfo_Header(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchType", wireType)
			}
			m.MatchType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchType |= EACLRecord_FilterInfo_MatchType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderVal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderVal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EACLRecord_TargetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= Target(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyList = append(m.KeyList, make([]byte, postIndex-iNdEx))
			copy(m.KeyList[len(m.KeyList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EACLTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EACLTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EACLTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerId == nil {
				m.ContainerId = &grpc.ContainerID{}
			}
			if err := m.ContainerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &EACLRecord{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
