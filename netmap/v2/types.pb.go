// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: netmap/v2/types.proto

package v2

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PlacementRule_SFGroup_Filter_SimpleFilter_Operation int32

const (
	PlacementRule_SFGroup_Filter_SimpleFilter_NP  PlacementRule_SFGroup_Filter_SimpleFilter_Operation = 0
	PlacementRule_SFGroup_Filter_SimpleFilter_EQ  PlacementRule_SFGroup_Filter_SimpleFilter_Operation = 1
	PlacementRule_SFGroup_Filter_SimpleFilter_NE  PlacementRule_SFGroup_Filter_SimpleFilter_Operation = 2
	PlacementRule_SFGroup_Filter_SimpleFilter_GT  PlacementRule_SFGroup_Filter_SimpleFilter_Operation = 3
	PlacementRule_SFGroup_Filter_SimpleFilter_GE  PlacementRule_SFGroup_Filter_SimpleFilter_Operation = 4
	PlacementRule_SFGroup_Filter_SimpleFilter_LT  PlacementRule_SFGroup_Filter_SimpleFilter_Operation = 5
	PlacementRule_SFGroup_Filter_SimpleFilter_LE  PlacementRule_SFGroup_Filter_SimpleFilter_Operation = 6
	PlacementRule_SFGroup_Filter_SimpleFilter_OR  PlacementRule_SFGroup_Filter_SimpleFilter_Operation = 7
	PlacementRule_SFGroup_Filter_SimpleFilter_AND PlacementRule_SFGroup_Filter_SimpleFilter_Operation = 8
)

var PlacementRule_SFGroup_Filter_SimpleFilter_Operation_name = map[int32]string{
	0: "NP",
	1: "EQ",
	2: "NE",
	3: "GT",
	4: "GE",
	5: "LT",
	6: "LE",
	7: "OR",
	8: "AND",
}

var PlacementRule_SFGroup_Filter_SimpleFilter_Operation_value = map[string]int32{
	"NP":  0,
	"EQ":  1,
	"NE":  2,
	"GT":  3,
	"GE":  4,
	"LT":  5,
	"LE":  6,
	"OR":  7,
	"AND": 8,
}

func (x PlacementRule_SFGroup_Filter_SimpleFilter_Operation) String() string {
	return proto.EnumName(PlacementRule_SFGroup_Filter_SimpleFilter_Operation_name, int32(x))
}

func (PlacementRule_SFGroup_Filter_SimpleFilter_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_059adda2b6daaf64, []int{0, 0, 0, 1, 0}
}

// Represents the enumeration of various states of the NeoFS node.
type NodeInfo_State int32

const (
	// Undefined state.
	NodeInfo_UNKNOWN NodeInfo_State = 0
	// Active state in the network.
	NodeInfo_ONLINE NodeInfo_State = 1
	// Network unavailable state.
	NodeInfo_OFFLINE NodeInfo_State = 2
)

var NodeInfo_State_name = map[int32]string{
	0: "UNKNOWN",
	1: "ONLINE",
	2: "OFFLINE",
}

var NodeInfo_State_value = map[string]int32{
	"UNKNOWN": 0,
	"ONLINE":  1,
	"OFFLINE": 2,
}

func (x NodeInfo_State) String() string {
	return proto.EnumName(NodeInfo_State_name, int32(x))
}

func (NodeInfo_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_059adda2b6daaf64, []int{1, 0}
}

type PlacementRule struct {
	ReplFactor           uint32                   `protobuf:"varint,1,opt,name=repl_factor,json=replFactor,proto3" json:"repl_factor,omitempty"`
	SfGroups             []*PlacementRule_SFGroup `protobuf:"bytes,2,rep,name=sf_groups,json=sfGroups,proto3" json:"sf_groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *PlacementRule) Reset()         { *m = PlacementRule{} }
func (m *PlacementRule) String() string { return proto.CompactTextString(m) }
func (*PlacementRule) ProtoMessage()    {}
func (*PlacementRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_059adda2b6daaf64, []int{0}
}
func (m *PlacementRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementRule.Merge(m, src)
}
func (m *PlacementRule) XXX_Size() int {
	return m.Size()
}
func (m *PlacementRule) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementRule.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementRule proto.InternalMessageInfo

func (m *PlacementRule) GetReplFactor() uint32 {
	if m != nil {
		return m.ReplFactor
	}
	return 0
}

func (m *PlacementRule) GetSfGroups() []*PlacementRule_SFGroup {
	if m != nil {
		return m.SfGroups
	}
	return nil
}

type PlacementRule_SFGroup struct {
	Filters              []*PlacementRule_SFGroup_Filter   `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"`
	Selectors            []*PlacementRule_SFGroup_Selector `protobuf:"bytes,2,rep,name=selectors,proto3" json:"selectors,omitempty"`
	Exclude              []uint32                          `protobuf:"varint,3,rep,packed,name=exclude,proto3" json:"exclude,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *PlacementRule_SFGroup) Reset()         { *m = PlacementRule_SFGroup{} }
func (m *PlacementRule_SFGroup) String() string { return proto.CompactTextString(m) }
func (*PlacementRule_SFGroup) ProtoMessage()    {}
func (*PlacementRule_SFGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_059adda2b6daaf64, []int{0, 0}
}
func (m *PlacementRule_SFGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementRule_SFGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementRule_SFGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementRule_SFGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementRule_SFGroup.Merge(m, src)
}
func (m *PlacementRule_SFGroup) XXX_Size() int {
	return m.Size()
}
func (m *PlacementRule_SFGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementRule_SFGroup.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementRule_SFGroup proto.InternalMessageInfo

func (m *PlacementRule_SFGroup) GetFilters() []*PlacementRule_SFGroup_Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *PlacementRule_SFGroup) GetSelectors() []*PlacementRule_SFGroup_Selector {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *PlacementRule_SFGroup) GetExclude() []uint32 {
	if m != nil {
		return m.Exclude
	}
	return nil
}

type PlacementRule_SFGroup_Filter struct {
	Key                  string                                     `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	F                    *PlacementRule_SFGroup_Filter_SimpleFilter `protobuf:"bytes,2,opt,name=f,proto3" json:"f,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *PlacementRule_SFGroup_Filter) Reset()         { *m = PlacementRule_SFGroup_Filter{} }
func (m *PlacementRule_SFGroup_Filter) String() string { return proto.CompactTextString(m) }
func (*PlacementRule_SFGroup_Filter) ProtoMessage()    {}
func (*PlacementRule_SFGroup_Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_059adda2b6daaf64, []int{0, 0, 0}
}
func (m *PlacementRule_SFGroup_Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementRule_SFGroup_Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementRule_SFGroup_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementRule_SFGroup_Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementRule_SFGroup_Filter.Merge(m, src)
}
func (m *PlacementRule_SFGroup_Filter) XXX_Size() int {
	return m.Size()
}
func (m *PlacementRule_SFGroup_Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementRule_SFGroup_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementRule_SFGroup_Filter proto.InternalMessageInfo

func (m *PlacementRule_SFGroup_Filter) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *PlacementRule_SFGroup_Filter) GetF() *PlacementRule_SFGroup_Filter_SimpleFilter {
	if m != nil {
		return m.F
	}
	return nil
}

type PlacementRule_SFGroup_Filter_SimpleFilters struct {
	Filters              []*PlacementRule_SFGroup_Filter_SimpleFilter `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilters) Reset() {
	*m = PlacementRule_SFGroup_Filter_SimpleFilters{}
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilters) String() string {
	return proto.CompactTextString(m)
}
func (*PlacementRule_SFGroup_Filter_SimpleFilters) ProtoMessage() {}
func (*PlacementRule_SFGroup_Filter_SimpleFilters) Descriptor() ([]byte, []int) {
	return fileDescriptor_059adda2b6daaf64, []int{0, 0, 0, 0}
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementRule_SFGroup_Filter_SimpleFilters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementRule_SFGroup_Filter_SimpleFilters.Merge(m, src)
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilters) XXX_Size() int {
	return m.Size()
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilters) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementRule_SFGroup_Filter_SimpleFilters.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementRule_SFGroup_Filter_SimpleFilters proto.InternalMessageInfo

func (m *PlacementRule_SFGroup_Filter_SimpleFilters) GetFilters() []*PlacementRule_SFGroup_Filter_SimpleFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

type PlacementRule_SFGroup_Filter_SimpleFilter struct {
	Op PlacementRule_SFGroup_Filter_SimpleFilter_Operation `protobuf:"varint,1,opt,name=op,proto3,enum=netmap.v2.PlacementRule_SFGroup_Filter_SimpleFilter_Operation" json:"op,omitempty"`
	// Types that are valid to be assigned to Args:
	//	*PlacementRule_SFGroup_Filter_SimpleFilter_Value
	//	*PlacementRule_SFGroup_Filter_SimpleFilter_FArgs
	Args                 isPlacementRule_SFGroup_Filter_SimpleFilter_Args `protobuf_oneof:"args"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter) Reset() {
	*m = PlacementRule_SFGroup_Filter_SimpleFilter{}
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilter) String() string {
	return proto.CompactTextString(m)
}
func (*PlacementRule_SFGroup_Filter_SimpleFilter) ProtoMessage() {}
func (*PlacementRule_SFGroup_Filter_SimpleFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_059adda2b6daaf64, []int{0, 0, 0, 1}
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementRule_SFGroup_Filter_SimpleFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementRule_SFGroup_Filter_SimpleFilter.Merge(m, src)
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilter) XXX_Size() int {
	return m.Size()
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementRule_SFGroup_Filter_SimpleFilter.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementRule_SFGroup_Filter_SimpleFilter proto.InternalMessageInfo

type isPlacementRule_SFGroup_Filter_SimpleFilter_Args interface {
	isPlacementRule_SFGroup_Filter_SimpleFilter_Args()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PlacementRule_SFGroup_Filter_SimpleFilter_Value struct {
	Value string `protobuf:"bytes,2,opt,name=value,proto3,oneof" json:"value,omitempty"`
}
type PlacementRule_SFGroup_Filter_SimpleFilter_FArgs struct {
	FArgs *PlacementRule_SFGroup_Filter_SimpleFilters `protobuf:"bytes,3,opt,name=f_args,json=fArgs,proto3,oneof" json:"f_args,omitempty"`
}

func (*PlacementRule_SFGroup_Filter_SimpleFilter_Value) isPlacementRule_SFGroup_Filter_SimpleFilter_Args() {
}
func (*PlacementRule_SFGroup_Filter_SimpleFilter_FArgs) isPlacementRule_SFGroup_Filter_SimpleFilter_Args() {
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter) GetArgs() isPlacementRule_SFGroup_Filter_SimpleFilter_Args {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter) GetOp() PlacementRule_SFGroup_Filter_SimpleFilter_Operation {
	if m != nil {
		return m.Op
	}
	return PlacementRule_SFGroup_Filter_SimpleFilter_NP
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter) GetValue() string {
	if x, ok := m.GetArgs().(*PlacementRule_SFGroup_Filter_SimpleFilter_Value); ok {
		return x.Value
	}
	return ""
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter) GetFArgs() *PlacementRule_SFGroup_Filter_SimpleFilters {
	if x, ok := m.GetArgs().(*PlacementRule_SFGroup_Filter_SimpleFilter_FArgs); ok {
		return x.FArgs
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PlacementRule_SFGroup_Filter_SimpleFilter) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PlacementRule_SFGroup_Filter_SimpleFilter_Value)(nil),
		(*PlacementRule_SFGroup_Filter_SimpleFilter_FArgs)(nil),
	}
}

type PlacementRule_SFGroup_Selector struct {
	Count                uint32   `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlacementRule_SFGroup_Selector) Reset()         { *m = PlacementRule_SFGroup_Selector{} }
func (m *PlacementRule_SFGroup_Selector) String() string { return proto.CompactTextString(m) }
func (*PlacementRule_SFGroup_Selector) ProtoMessage()    {}
func (*PlacementRule_SFGroup_Selector) Descriptor() ([]byte, []int) {
	return fileDescriptor_059adda2b6daaf64, []int{0, 0, 1}
}
func (m *PlacementRule_SFGroup_Selector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementRule_SFGroup_Selector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementRule_SFGroup_Selector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementRule_SFGroup_Selector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementRule_SFGroup_Selector.Merge(m, src)
}
func (m *PlacementRule_SFGroup_Selector) XXX_Size() int {
	return m.Size()
}
func (m *PlacementRule_SFGroup_Selector) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementRule_SFGroup_Selector.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementRule_SFGroup_Selector proto.InternalMessageInfo

func (m *PlacementRule_SFGroup_Selector) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *PlacementRule_SFGroup_Selector) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// Groups the information about the NeoFS node.
type NodeInfo struct {
	// Carries network address of the NeoFS node.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Carries public key of the NeoFS node in a binary format.
	PublicKey []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Carries list of the NeoFS node attributes in a string key-value format.
	Attributes []*NodeInfo_Attribute `protobuf:"bytes,3,rep,name=attributes,proto3" json:"attributes,omitempty"`
	// Carries state of the NeoFS node.
	State                NodeInfo_State `protobuf:"varint,4,opt,name=state,proto3,enum=netmap.v2.NodeInfo_State" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_059adda2b6daaf64, []int{1}
}
func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *NodeInfo) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *NodeInfo) GetAttributes() []*NodeInfo_Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *NodeInfo) GetState() NodeInfo_State {
	if m != nil {
		return m.State
	}
	return NodeInfo_UNKNOWN
}

// Groups attributes of the NeoFS node.
type NodeInfo_Attribute struct {
	// Carries string key to the node attribute.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Carries string value of the node attribute.
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeInfo_Attribute) Reset()         { *m = NodeInfo_Attribute{} }
func (m *NodeInfo_Attribute) String() string { return proto.CompactTextString(m) }
func (*NodeInfo_Attribute) ProtoMessage()    {}
func (*NodeInfo_Attribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_059adda2b6daaf64, []int{1, 0}
}
func (m *NodeInfo_Attribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo_Attribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo_Attribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo_Attribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo_Attribute.Merge(m, src)
}
func (m *NodeInfo_Attribute) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfo_Attribute) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo_Attribute.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo_Attribute proto.InternalMessageInfo

func (m *NodeInfo_Attribute) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *NodeInfo_Attribute) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func init() {
	proto.RegisterEnum("netmap.v2.PlacementRule_SFGroup_Filter_SimpleFilter_Operation", PlacementRule_SFGroup_Filter_SimpleFilter_Operation_name, PlacementRule_SFGroup_Filter_SimpleFilter_Operation_value)
	proto.RegisterEnum("netmap.v2.NodeInfo_State", NodeInfo_State_name, NodeInfo_State_value)
	proto.RegisterType((*PlacementRule)(nil), "netmap.v2.PlacementRule")
	proto.RegisterType((*PlacementRule_SFGroup)(nil), "netmap.v2.PlacementRule.SFGroup")
	proto.RegisterType((*PlacementRule_SFGroup_Filter)(nil), "netmap.v2.PlacementRule.SFGroup.Filter")
	proto.RegisterType((*PlacementRule_SFGroup_Filter_SimpleFilters)(nil), "netmap.v2.PlacementRule.SFGroup.Filter.SimpleFilters")
	proto.RegisterType((*PlacementRule_SFGroup_Filter_SimpleFilter)(nil), "netmap.v2.PlacementRule.SFGroup.Filter.SimpleFilter")
	proto.RegisterType((*PlacementRule_SFGroup_Selector)(nil), "netmap.v2.PlacementRule.SFGroup.Selector")
	proto.RegisterType((*NodeInfo)(nil), "netmap.v2.NodeInfo")
	proto.RegisterType((*NodeInfo_Attribute)(nil), "netmap.v2.NodeInfo.Attribute")
}

func init() { proto.RegisterFile("netmap/v2/types.proto", fileDescriptor_059adda2b6daaf64) }

var fileDescriptor_059adda2b6daaf64 = []byte{
	// 633 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x41, 0x6b, 0xdb, 0x4a,
	0x10, 0xb6, 0xa4, 0x58, 0xb6, 0xc6, 0xf1, 0x43, 0x2c, 0x79, 0x0f, 0x3d, 0x43, 0xfc, 0x8c, 0x2f,
	0xcf, 0xa5, 0x58, 0x06, 0xa5, 0x3d, 0xa6, 0xe0, 0x50, 0x3b, 0x0d, 0x09, 0x6b, 0x77, 0x9d, 0x52,
	0xe8, 0xc5, 0xc8, 0xf2, 0xca, 0x15, 0x95, 0xb5, 0x42, 0xbb, 0x32, 0xcd, 0x2f, 0x69, 0x7f, 0x40,
	0x4f, 0xfd, 0x11, 0x3d, 0xf7, 0xd0, 0x43, 0x7f, 0x42, 0x49, 0xa1, 0xbf, 0xa3, 0xec, 0xda, 0x72,
	0x9d, 0x12, 0x48, 0xc9, 0x69, 0x34, 0xdf, 0xce, 0xf7, 0xcd, 0xec, 0xcc, 0x68, 0xe1, 0xef, 0x84,
	0x8a, 0xa5, 0x9f, 0xf6, 0x56, 0x5e, 0x4f, 0x5c, 0xa5, 0x94, 0xbb, 0x69, 0xc6, 0x04, 0x43, 0xd6,
	0x1a, 0x76, 0x57, 0x5e, 0xfb, 0x93, 0x09, 0xf5, 0x71, 0xec, 0x07, 0x74, 0x49, 0x13, 0x41, 0xf2,
	0x98, 0xa2, 0xff, 0xa0, 0x96, 0xd1, 0x34, 0x9e, 0x86, 0x7e, 0x20, 0x58, 0xe6, 0x68, 0x2d, 0xad,
	0x53, 0x27, 0x20, 0xa1, 0xa1, 0x42, 0xd0, 0x31, 0x58, 0x3c, 0x9c, 0x2e, 0x32, 0x96, 0xa7, 0xdc,
	0xd1, 0x5b, 0x46, 0xa7, 0xe6, 0xb5, 0xdc, 0xad, 0xa2, 0x7b, 0x43, 0xcd, 0x9d, 0x0c, 0x4f, 0x65,
	0x20, 0xa9, 0xf2, 0x50, 0x7d, 0xf0, 0xc6, 0x97, 0x32, 0x54, 0x36, 0x28, 0xea, 0x43, 0x25, 0x8c,
	0x62, 0x41, 0x33, 0xee, 0x68, 0x4a, 0xe8, 0xff, 0xbb, 0x84, 0xdc, 0xa1, 0x8a, 0x27, 0x05, 0x0f,
	0x9d, 0x82, 0xc5, 0x69, 0x4c, 0x65, 0x65, 0x45, 0x35, 0x0f, 0xee, 0x14, 0x99, 0x6c, 0x18, 0xe4,
	0x17, 0x17, 0x39, 0x50, 0xa1, 0x6f, 0x83, 0x38, 0x9f, 0x53, 0xc7, 0x68, 0x19, 0x9d, 0x3a, 0x29,
	0xdc, 0xc6, 0x0f, 0x03, 0xcc, 0x75, 0x5a, 0x64, 0x83, 0xf1, 0x86, 0x5e, 0xa9, 0xa6, 0x58, 0x44,
	0x7e, 0xa2, 0x13, 0xd0, 0x42, 0x47, 0x6f, 0x69, 0x9d, 0x9a, 0xf7, 0xe8, 0x0f, 0x8b, 0x77, 0x27,
	0xd1, 0x32, 0x8d, 0xe9, 0xe6, 0x26, 0x5a, 0xd8, 0x98, 0x42, 0x7d, 0x17, 0xe2, 0x08, 0xff, 0xde,
	0x97, 0xfb, 0x49, 0x17, 0x22, 0x8d, 0x0f, 0x3a, 0xec, 0xef, 0x9e, 0x20, 0x0c, 0x3a, 0x4b, 0xd5,
	0x35, 0xfe, 0xf2, 0x9e, 0xdc, 0x47, 0xdb, 0x1d, 0xa5, 0x34, 0xf3, 0x45, 0xc4, 0x12, 0xa2, 0xb3,
	0x14, 0xfd, 0x03, 0xe5, 0x95, 0x1f, 0xe7, 0x54, 0x75, 0xc2, 0x7a, 0x56, 0x22, 0x6b, 0x17, 0x61,
	0x30, 0xc3, 0xa9, 0x9f, 0x2d, 0xb8, 0x63, 0xa8, 0x16, 0x3d, 0xbe, 0x4f, 0x2e, 0x2e, 0xf5, 0xc2,
	0x7e, 0xb6, 0xe0, 0xed, 0x4b, 0xb0, 0xb6, 0x89, 0x91, 0x09, 0x3a, 0x1e, 0xdb, 0x25, 0x69, 0x07,
	0xcf, 0x6d, 0x4d, 0xf9, 0x03, 0x5b, 0x97, 0xf6, 0xf4, 0xd2, 0x36, 0x94, 0x1d, 0xd8, 0x7b, 0xd2,
	0x5e, 0x5c, 0xda, 0x65, 0x65, 0x07, 0xb6, 0x29, 0xed, 0x88, 0xd8, 0x15, 0x54, 0x01, 0xa3, 0x8f,
	0x9f, 0xda, 0xd5, 0x13, 0x13, 0xf6, 0x64, 0x8d, 0x0d, 0x0f, 0xaa, 0xc5, 0x66, 0xa0, 0x03, 0x28,
	0x07, 0x2c, 0x4f, 0xc4, 0xe6, 0x07, 0x58, 0x3b, 0xc5, 0xfc, 0xf5, 0xed, 0xfc, 0xdb, 0xef, 0x74,
	0xa8, 0x62, 0x36, 0xa7, 0x67, 0x49, 0xc8, 0xe4, 0x0e, 0xf9, 0xf3, 0x79, 0x46, 0x39, 0xdf, 0xac,
	0x48, 0xe1, 0xa2, 0x43, 0x80, 0x34, 0x9f, 0xc5, 0x51, 0x30, 0x2d, 0xf8, 0xfb, 0xc4, 0x5a, 0x23,
	0xe7, 0xf4, 0x0a, 0x1d, 0x03, 0xf8, 0x42, 0x64, 0xd1, 0x2c, 0x17, 0x94, 0xab, 0xfd, 0xab, 0x79,
	0x87, 0x3b, 0xbd, 0x2a, 0x32, 0xb8, 0xfd, 0x22, 0x8a, 0xec, 0x10, 0x50, 0x0f, 0xca, 0x5c, 0xf8,
	0x82, 0x3a, 0x7b, 0x6a, 0xa2, 0xff, 0xde, 0xc6, 0x9c, 0xc8, 0x00, 0xb2, 0x8e, 0x6b, 0x1c, 0x81,
	0xb5, 0x55, 0xba, 0x65, 0xa9, 0x0f, 0x6e, 0x8c, 0x73, 0x33, 0xcc, 0x76, 0x17, 0xca, 0x4a, 0x04,
	0xd5, 0xa0, 0xf2, 0x02, 0x9f, 0xe3, 0xd1, 0x4b, 0x6c, 0x97, 0x10, 0x80, 0x39, 0xc2, 0x17, 0x67,
	0x78, 0x60, 0x6b, 0xf2, 0x60, 0x34, 0x1c, 0x2a, 0x47, 0x3f, 0x19, 0x7f, 0xbe, 0x6e, 0x6a, 0x5f,
	0xaf, 0x9b, 0xda, 0xb7, 0xeb, 0xa6, 0xf6, 0xfe, 0x7b, 0xb3, 0xf4, 0xea, 0xe1, 0x22, 0x12, 0xaf,
	0xf3, 0x99, 0x1b, 0xb0, 0x65, 0x2f, 0xe1, 0x69, 0x10, 0x74, 0xe7, 0x74, 0xd5, 0x4b, 0x28, 0x0b,
	0x79, 0xd7, 0x4f, 0xa3, 0xee, 0x82, 0xf5, 0xb6, 0x0f, 0xd6, 0x47, 0xdd, 0xc6, 0x94, 0x0d, 0x27,
	0x6e, 0x7f, 0x7c, 0xe6, 0x62, 0x85, 0xce, 0x4c, 0xf5, 0x7c, 0x1d, 0xfd, 0x0c, 0x00, 0x00, 0xff,
	0xff, 0xb9, 0x8b, 0x54, 0xcf, 0xd7, 0x04, 0x00, 0x00,
}

func (m *PlacementRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SfGroups) > 0 {
		for iNdEx := len(m.SfGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SfGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ReplFactor != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ReplFactor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlacementRule_SFGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementRule_SFGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementRule_SFGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Exclude) > 0 {
		dAtA2 := make([]byte, len(m.Exclude)*10)
		var j1 int
		for _, num := range m.Exclude {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Selectors) > 0 {
		for iNdEx := len(m.Selectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Selectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PlacementRule_SFGroup_Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementRule_SFGroup_Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementRule_SFGroup_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.F != nil {
		{
			size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Args != nil {
		{
			size := m.Args.Size()
			i -= size
			if _, err := m.Args.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Op != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter_Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter_Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilter_FArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter_FArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FArgs != nil {
		{
			size, err := m.FArgs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PlacementRule_SFGroup_Selector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementRule_SFGroup_Selector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementRule_SFGroup_Selector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Count != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfo_Attribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo_Attribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo_Attribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PlacementRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplFactor != 0 {
		n += 1 + sovTypes(uint64(m.ReplFactor))
	}
	if len(m.SfGroups) > 0 {
		for _, e := range m.SfGroups {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlacementRule_SFGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Exclude) > 0 {
		l = 0
		for _, e := range m.Exclude {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlacementRule_SFGroup_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.F != nil {
		l = m.F.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovTypes(uint64(m.Op))
	}
	if m.Args != nil {
		n += m.Args.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlacementRule_SFGroup_Filter_SimpleFilter_Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilter_FArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FArgs != nil {
		l = m.FArgs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PlacementRule_SFGroup_Selector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovTypes(uint64(m.Count))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeInfo_Attribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PlacementRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlacementRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlacementRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplFactor", wireType)
			}
			m.ReplFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SfGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SfGroups = append(m.SfGroups, &PlacementRule_SFGroup{})
			if err := m.SfGroups[len(m.SfGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementRule_SFGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SFGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SFGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &PlacementRule_SFGroup_Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &PlacementRule_SFGroup_Selector{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Exclude = append(m.Exclude, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Exclude) == 0 {
					m.Exclude = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Exclude = append(m.Exclude, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementRule_SFGroup_Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.F == nil {
				m.F = &PlacementRule_SFGroup_Filter_SimpleFilter{}
			}
			if err := m.F.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleFilters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleFilters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &PlacementRule_SFGroup_Filter_SimpleFilter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementRule_SFGroup_Filter_SimpleFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= PlacementRule_SFGroup_Filter_SimpleFilter_Operation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = &PlacementRule_SFGroup_Filter_SimpleFilter_Value{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PlacementRule_SFGroup_Filter_SimpleFilters{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Args = &PlacementRule_SFGroup_Filter_SimpleFilter_FArgs{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementRule_SFGroup_Selector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Selector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Selector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &NodeInfo_Attribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= NodeInfo_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo_Attribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
